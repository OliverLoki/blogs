**引言**

> **Java世界中“几乎”所有的对象都在堆中分配，《深入理解 Java 虚拟机中》关于 Java 堆内存有这样一段描述：随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，`栈上分配`,`标量替换`优化技术将会导致一些变化，所有的对象都分配到堆上也渐渐变得不那么"绝对"了。**
>
> **从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存**

问题引入：**对象和数组并非都是在堆上分配内存的**

怎么理解呢？

> **标量替换**

- 标量不可在分解的量，java 的基本数据类型就是标量，标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在 JAVA 中对象就是可以被进一步分解的聚合量
- 替换过程，通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM 不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。

> **逃逸分析**

- 这是一种可以有效减少 Java 内存堆分配压力的分析算法，通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

- 当一个对象在方法中被定义后，它可能被外部方法所引用，如作为调用参数传递到其他地方中，称为`方法逃逸`。

- 再如赋值给类变量或可以在其他线程中访问的实例变量，称为`线程逃逸`

- 使用逃逸分析，编译器可以对代码做如下优化：

  - 同步省略：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
  - 将堆分配转化为栈分配：如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。
  - 分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器中。

```java
public static StringBuffer createStringBuffer(String s1, String s2) {

    StringBuffer s = new StringBuffer();

    s.append(s1);

    s.append(s2);

    return s;
}
```

s 是一个方法内部变量，上边的代码中直接将 s 返回，这个 StringBuffer 的对象有可能被其他方法所改变，导致它的作用域就不只是在方法内部，即使它是一个局部变量，但还是逃逸到了方法外部，称为`方法逃逸`。

还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为`线程逃逸`



- 在编译期间，如果 JIT 经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。
- jvm 参数设置，`-XX:+DoEscapeAnalysis` ：开启逃逸分析 ，`-XX:-DoEscapeAnalysis` ： 关闭逃逸分析
- 从 jdk 1.7 开始已经默认开始逃逸分析