**为什么redis需要事务和锁？**

> 首先需要说明一点的是：我们一直在强调 redis 是单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的
>
> 
>
>
> 我们需要注意的是：redis是单线程这是毋庸置疑的。redis 本身是不会产生并发安全问题的，不需要加锁。再多的 commands 都是 one by one 执行的。这里说的加锁是我们为了满足业务在使用的时候，可能会出现并发问题而需要加锁
>
> 
>
> 比如，当一个 redis 服务器同时有多个客户端访问时，每个客户端会有一个线程。客户端访问之间存在竞争。因为存在多客户端并发，所以必须保证操作的原子性。比如银行卡扣款问题，获取余额，判断，扣款就必须构成事务，否则就可能出错
>
> 
>
> 在传统单体应用单机部署的情况下，可以使用Java并发相关的锁，如`ReentrantLcok`或`synchronized`进行互斥控制。但是，随着业务发展的需要，原单体单机部署的系统，渐渐的被部署在多机器多JVM上同时提供服务，这使得原单机部署情况下的并发控制锁策略失效了，为了解决这个问题就需要一种`跨JVM的互斥机制来控制共享资源的访问`，这就是分布式锁要解决的问题。
>
> 
>
> 分布式环境下，数据一致性问题一直是一个比较重要的话题，而又不同于单进程的情况。`分布式与单机情况下最大的不同在于其不是多线程而是多进程`。多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方=>可以用 redis 来实现分布式锁。

**分布式锁的实现条件**

> 1、互斥性：要保证任意时刻，只能有一个客户端持有锁。
>
> 2、可靠性：要保证系统的稳定性，不能产生死锁。
>
> 3、一致性：要保证锁只能由加锁人解锁，不能产生A的加锁被B用户解锁的情况。

##  Redis事务

### 事务的ACID原则

**关系型数据库遵循ACID规则**,事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：

+ A (Atomicity) 原子性
+ C (Consistency) 一致性
+ I (Isolation) 独立性
+ D (Durability) 持久性

为了确保连续多个操作的原子性，我们常用的数据库都会有事务的支持，Redis 也不例外。但它又和关系型数据库不太一样，先来看一下传统数据库事务过程

### 传统数据库事务过程

在关系型数据库中，我们开启事务并进行一系列的读写操作，最后，用户用户可以选择发送commit来确认之前的修改，或者发送rollback来放弃之前的修改

```java
Connection conn = ... //获取数据库连接
conn.setAutoCommit(false); //开启事务
try{
   //......执行增删改查sql
   //......执行增删改查sql
   conn.commit(); //提交事务
}catch (Exception e) {
  conn.rollback();//事务回滚
}finally{
   conn.close();//关闭链接
}
```

### Redis事务过程与相关命令

1. 开启事务

   ```
   multi
   ```

2. 命令入队

3. 执行事务（exec）

   ```
   exec
   ```

> 注：事务执行途中可以使用`discard`命令，这样整个队列都会被取消，所有命令都不执行
>
> ```
> discard
> ```



**举个栗子**

如下所示，所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成

```bash
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> set key1 value1
QUEUED
127.0.0.1:6379(TX)> set key2 value2
QUEUED
127.0.0.1:6379(TX)> exec
1) OK
2) OK
```

**相关命令总结**

下表列出了 redis 事务的相关命令：

| 序号 | 命令及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | [DISCARD](https://www.runoob.com/redis/transactions-discard.html) 取消事务，放弃执行事务块内的所有命令。 |
| 2    | [EXEC](https://www.runoob.com/redis/transactions-exec.html) 执行所有事务块内的命令。 |
| 3    | [MULTI](https://www.runoob.com/redis/transactions-multi.html) 标记一个事务块的开始。 |
| 4    | [UNWATCH](https://www.runoob.com/redis/transactions-unwatch.html) 取消 WATCH 命令对所有 key 的监视。 |
| 5    | [WATCH key [key ...\]](https://www.runoob.com/redis/transactions-watch.html) 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 |

### Redis事务的特性

+ 事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，执行过程中按顺序执行，不允许其他客户端提交的命令插队
+ 得益于单线程模型的内存处理，没有并发事务，所以Redis事务没有隔离级别的概念，批量操作在发送 `EXEC` 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到

+ Redis单条命令是保证原子性的，但是事务不保证原子性，且不能回滚

> **错误处理**

+ 事务组队过程中中出现了错误（如语法错误），整个执行队列都会被取消

+ 执行任意命令执行失败，其余的命令仍会被执行

> **Redis为什么不支持回滚rollback？**
>
> + 为了高性能
> + 操作失败的原因只可能是语法错误或者错误的数据类型操作

Redis 操作失败的原因只可能是语法错误或者错误的数据类型操作，这些都是在开发期间能发现的问题，不会进入到生产环境，因此不需要回滚。
Redis 内部设计推崇简单和高性能，支持事务回滚能力会导致设计复杂，这与Redis的初衷相违背，因此不需要回滚能力。
Redis 的应用场景明显不是为了数据存储的高可靠与强一致性而设计的，而是为了数据访问的高性能而设计，设计者为了简单性和高性能而部分放弃了原子性



### 事务的冲突与乐观锁、悲观锁

**[Redis悲观锁、乐观锁和调用Lua脚本三种方式的优缺点](http://c.biancheng.net/view/4610.html)**

> 关于乐观锁和悲观锁

**乐观锁**

+ 乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做

+ 主要用于抢红包，淘宝抢购，秒杀之类，在秒杀这种高并发环境下，容易造成超卖问题。如，在一件商品只剩一件时，这时A用户开启事务只准备抢购，而就在A完成事务之前，B用户已经抢了这件商品，当A完成事务后，库存数量为-1。为了解决这个问题，可以引进悲观锁

**悲观锁**

+ 

悲观锁：这个世界一切东西都是不可信的。在redis中，悲观锁指的是对数据key和都value都上锁，只要这个数据有一点小改动，事务将失败。因此上面的秒杀活动，在开启事务前，可对库存上锁：watch，只要在这个watch之后，别的进程或线程对这个库存有修改，本线程的事务将不会执行成功。







