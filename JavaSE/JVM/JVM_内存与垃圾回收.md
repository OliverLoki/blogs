

> + JDK版本：`jdk-11.0.7`，文中所有代码都在JDK11环境下运行成功
> + 虚拟机版本：`Java HotSpot(TM) 64-Bit Server VM 18.9`

**学习过程中主要参考资料**

> [1] 深入理解Java虚拟机：JVM高级特性与最佳实践(第3版) - 周志明(2019)
>
> [2] [尚硅谷宋红康JVM全套教程（详解java虚拟机）](https://www.bilibili.com/video/BV1PJ411n7xZ?)
>
> [3] Java语言与虚拟机规范[Java Language and Virtual Machine Specifications](https://docs.oracle.com/javase/specs/index.html)

**注：相对于以上资料的完备性，Loki由于个人博客的实用性，也因为当今Java版权已经趋于稳定化，因此对于Java发展的历程的许多故事或者其他非技术性的内容就不多做整理，读者可以根据需要自行查找阅读**



![image-20220411180112212](https://s2.loli.net/2022/04/12/B3RJlGnfxo5wQhc.png)



# 一、走进Java与JVM

## 学习JVM的必要性

> 通常情况下，一个程序员只要了解了必要的Java类库API、Java语法，学习适当的第三方开发框架，就已经基本满足日常开发的需要了。虚拟机会在用户不知不觉中完成对硬件平台的兼容及对内存等资源的管理工作
>
> 因此，了解虚拟机的运作并不是普通开发人员必备的，或者说首要学习的知识
>
> 然而，凡事都具备两面性。随着Java技术的不断发展，它已被应用于越来越多的领域之中。其中一些领域，如互联网、能源、金融、通信等，对程序的性能、稳定性和扩展性方面会有极高的要求。一段程序很可能在10个人同时使用时完全正常，但是在10000个人同时使用时就会缓慢、死锁甚至崩溃。毫无疑问，要满足10000个人同时使用，需要更高性能的物理硬件，但是在绝大多数情况下，提升硬件性能无法等比例提升程序的运行性能和并发能力，甚至有可能对程序运行状况没有任何改善。这里面有Java虚拟机的原因:为了达到“所有硬件提供一致的虚拟平台”的目的，牺牲了一些硬件相关的性能特性。更重要的是人为原因:如果开发人员不了解虚拟机诸多技术特性的运行原理,就无法写出最适合虚拟机运行和自优化的代码
> 其实，目前商用的高性能Java虚拟机都提供了相当多的优化参数和调节手段，用于满足应用程序在实际生产环境中对性能和稳定性的要求。如果只是为了入门学习，让程序在自己的机器上正常工作，那么这些特性可以说是可有可无的;但是，如果用于生产开发，尤其是大规模的、企业级的生产开发，就迫切需要开发人员中至少有一部分人对虚拟机的特性及调节方法具有很清晰的认识。所以在Java开发体系中，对架构师、系统调优师、高级程序员等角色的需求一直都非常大
>
> 学习虚拟机中各种自动运作特性的原理也成为Java程序员成长路上最终必然会接触到的一课

## 进一步认识Java

相信各位来阅读JVM之前已经对Java语言有了不浅的理解，所以这里对于Java的安装、环境变量配置、语法特性等基础就不再多做描述

### Oracle JDK与Open JDK

**背景：**

在编写这篇文章时，`Oracle JDK`已经更新到JKD18,最新的LTS（长期支持）版本为`JDK17`，市场最多使用的仍然是JDK8（主流的 JDK 8 在2019年01月之后就被宣布停止更新了）

> **Oracle JDK**
>
> Oracle JDK 由 Oracle 维护和开发。它符合 OpenJDK 规范，但不是开源代码。Oracle JDK 在 JVM 响应能力和生产力方面要好得多。由于其对企业客户的重要性，它更注重稳定性

> **OpenJDK**
>
> OpenJDK是开放源代码，由Oracle维护和开发，但允许社区和其他公司参与开发，如Red Hat、Azul Systems、IBM、Apple Inc等。OpenJDK既是一种JDK产品，也是一种规范，任何想要使用OpenJDK创建新变体的公司或组织都必须遵守这些规范

**Oracle JDK和OpenJDK的异同点**

+ `Oracle JDK` 比 `OpenJDK` 更稳定，在JDK11中，我们可以认为OpenJDK和OracleJDK代码实质上已经完全一致的程度
+ `OpenJDK`和`Oracle JDK`的代码几乎相同，但`Oracle JDK`有更多的类和一些错误修复
+ 二者共同使用`Hotspot`虚拟机(它采用解释器与编译器并存的架构)
+ 许可协议不同：Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可

**如何对二者做出选择？**

Oracle JDK的特点是单版本长期支持，如开发企业/商业软件，一般建议选择Oracle JDK，因为它经过了彻底的测试和稳定OpenJDK的特点是更新频繁，实现快速迭代和高效试错，为Oracle JDK LTS版本打下基础

商用收费，学习研究免费。如需在开源基础上开发及问题优化维护或不那么注重稳定性，则可以选择OpenJDK

### Java语言的地位

每年都有很多新、旧编程语言的兴起躁动与消失，说明必然有其需求动力所在，譬如互联网之于JavaScript、人工智能之于Python，微服务风潮之于Golang等。大家都清楚不太可能有哪门语言能在每一个领域都尽占优势，Java已是距离这个目标最接近的选项，但若“天下第一”还要百尺竿头更进一步的话，似乎就只能忘掉Java语言本身，踏入无招胜有招的境界

> 附：**TIOBE Index for April 2022**（编程语言排行榜，每个月更新，只截取前10名）

![image-20220411182014889](https://s2.loli.net/2022/04/12/SAdqNFb3oeHU47n.png)

### Java上层框架与JVM的关系

> Java是目前用户最多、使用范围最广的软件开发技术，Java的技术体系主要由支撑Java程序运行的虚拟机、提供各开发领域接口支持的Java类库、Java编程语言及许许多多的第三方Java框架（如Spring、MyBatis等）构成。在国内，有关Java类库API、Java语言语法及第三方框架的技术资料和书籍非常丰富，相比而言，有关Java虚拟机的资料却显得异常贫乏
> 这种状况很大程度上是由Java开发技术本身的一个重要优点导致的:在虚拟机层面隐藏了底层技术的复杂性以及机器与操作系统的差异性。运行程序的物理机千差万别，而Java虚拟机则在千差万别的物理机上面建立了统一的运行平台，实现了在任意一台Java虚拟机上编译的程序，都能在任何其他Java虚拟机上正常运行。这一极大的优势使得Java应用的开发比传统C/C++应用的开发更高效快捷，程序员可以把主要精力放在具体业务逻辑，而不是放在保障物理硬件的兼容性上

即便如此，Loki认为正如大树扎根一样，对于内功和底层的修炼，才是我们能立足于越来越内卷的环境的根本

> + 数据结构与算法
> + 计算机网络
> + 计算机组成原理
> + 操作系统原理
> + 数据库系统

### Java代码的执行流程

![image-20220412164615294](https://s2.loli.net/2022/04/12/KAZqDLYXh9nRHo4.png)





## 初识JVM——跨语言的平台

> **首先理解JVM的两个特性**
>
> + **跨平台**
>
>   **通过不同平台指令集、不同机器码下的虚拟机，可以运行同样的字节码文件，达到同样的结果，以此达到虚拟机跨平台的特性**
>
> + **语言无关性**
>
>   **通过不同的编译器，可以编译出符合统一字节码规范的字节码文件，交由JVM处理，屏蔽了不同编程语言的特性**

![image-20220411183813926](https://s2.loli.net/2022/04/12/TM9b8XFlvzsoWC5.png)



**解释Java为什么是半编译半解释型语言**

> **我们需要格外注意的是 .class->机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是半编译半解释型语言**

### 虚拟机是什么

虚拟机(Virtual Machine)，就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。

+ `Visual Box`，`VMware`就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台
+ 程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令

无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中

### JVM发展历程

由于`OracleJDK/OpenJDK`在市场占有率上的绝对优势，它默认的HotSpot虚拟机不可避免地成为我们主要学习的对象，因此Loki的这篇JVM学习博客将以HotSpot虚拟机为学习目标,进行展开学习

**（注：下文中JVM默认指Hotspot虚拟机）**

> **来简单看一看JVM虚拟机家族的其他部分成员**

+ 虚拟机始祖:`Sun Classic/ExactVM`

  以今天的视角来看，Sun Classic虚拟机的技术已经相当原始，这款虚拟机的使命也早已终结。但仅凭它“世界上第一款商用Java虚拟机”的头衔，就足够有令历史记住它的理由

+ 武林盟主:`HotSpot VM`

  它是Sun/OracleJDK和OpenJDK中的默认Java虚拟机，也是目前使用范围最广的Java虚拟机，通过热点代码探测技术在响应时间与执行性能中取得平衡

+ 小家碧玉: `Mobile/EmbeddedVM`
  Sun/Oracle公司面对移动和嵌入式市场所研发的虚拟机,目前国内市场几乎看不到应用了

+ 专注于服务器端应用：`JRockit`（已经被Oracle收购，整合到Hotspot中了）

  它可以不太关注程序启动速度，因此JRockit内部不包含解释器实现，全部代码都靠即时编译器编译后执行 
  大量的行业基准测试显示，JRockit JVM是世界上最快的JVM

### JVM架构模型

Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别

> **基于栈式架构的特点**
>
> - 设计和实现更简单，适用于资源受限的系统
>
> - 避开了寄存器的分配难题：使用零地址指令方式分配
>
> - 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现
>
> - 不需要硬件支持，可移植性更好，更好实现跨平台

> **基于寄存器架构的特点**
>
> - 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机
>
> - 指令集架构则完全依赖硬件，可移植性差
>
> - 性能优秀和执行更高效
>
> - 花费更少的指令去完成一项操作
>
> - 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主

**举个栗子：int a = 2 + 3**

基于栈的计算流程

```
iconst_2 //常量2入栈
istore_1
iconst_3 // 常量3入栈
istore_2
iload_1
iload_2
iadd //常量2/3出栈，执行相加
istore_0 // 结果5入栈
```

基于寄存器的运算流程

```
mov eax,2 //将eax寄存器的值设为1
add eax,3 //使eax寄存器的值加3
```

**由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令**

### 初探JVM内存结构

以Hotspot为例

名称中的Hotspot指的就是它的热点代码探测技术

> 1. 通过计数器找到最具编译价值代码，触发即时编译或栈上替换
> 2. 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡

JVM的内存空间分为 5 个部分

> 第二节：类装载器
>
> 第三节：运行时数据区
>
> 第四节：执行引擎

![image-20220411225511956](https://s2.loli.net/2022/04/12/VFhyNxPB4X6irsH.png)

**注：**

1. **方法区和堆线程共享**
2. **Java栈、本地方法栈、程序计数器线程私有**

### JVM的生命周期

> **虚拟机的启动**
>
> Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。

> **虚拟机的执行**
>
> - 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。
>
> - 程序开始执行时他才运行，程序结束时他就停止。
>
> - 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。

> **虚拟机的退出**
>
> 有如下的几种情况：
>
> - 程序正常执行结束
>
> - 程序在执行过程中遇到了异常或错误而异常终止
>
> - 由于操作系统用现错误而导致Java虚拟机进程终止
>
> - 某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。
>
> - 除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。





# 二、类加载器与类加载过程

> Java 源代码首先需要使用 Javac 编译器编译成 .class 文件，然后由`类加载器(ClassLoader)`**把描述类的数据从Class文件加载到内存**，并对数据进行一系列处理，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作**虚拟机的类加载机制**。

总结：本小节就是是对以下这个图的详细学习整理

![image-20220412192639497](https://s2.loli.net/2022/04/12/W32fOHDVlSNBvLq.png)

## .Class文件详解

**代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步**

### 字节码文件结构

**Class 文件是二进制文件，它的内容具有严格的规范，文件中没有任何空格，全都是连续的 0/1**

> Class 文件中的所有内容被分为两种类型：无符号数、表

- 无符号数 无符号数表示 Class 文件中的值，这些值没有任何类型，但有不同的长度。u1、u2、u4、u8 分别代表 1/2/4/8 字节的无符号数。
- 表是由多个无符号数或者其他表作为数据项构成的复合数据类型

> 附:baggage_claim:Class字节码文件结构表

| 名称           | 类型             | 名称                | 说明                   |
| -------------- | ---------------- | ------------------- | ---------------------- |
| 魔数           | u4               | magic               | 魔数,识别Class文件格式 |
| 版本号         | u2               | minor_version       | 副版本号(小版本)       |
| u2             | major_version    | 主版本号(大版本)    | 2个字节                |
| 常量池集合     | u2               | constant_pool_count | 常量池计数器           |
| cp_info        | constant_pool    | 常量池表            | n个字节                |
| 访问标识       | u2               | access_flags        | 访问标识               |
| 索引集合       | u2               | this_class          | 类索引                 |
| u2             | super_class      | 父类索引            | 2个字节                |
| u2             | interfaces_count | 接口计数器          | 2个字节                |
| u2             | interfaces       | 接口索引集合        | 2个字节                |
| 字段表集合     | u2               | fields_count        | 字段计数器             |
| field_info     | fields           | 字段表              | n个字节                |
| 方法表集合     | u2               | methods_count       | 方法计数器             |
| method_info    | methods          | 方法表              | n个字节                |
| 属性表集合     | u2               | attributes_count    | 属性计数器             |
| attribute_info | attributes       | 属性表              | n个字节                |

对其中几个字段做出解释：

> 魔数

+ 每个Class文件开头的4个字节的无符号整数称为魔数（Magic Number）
+ 它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的Class文件。即：魔数是Class文件的标识符。

- 魔数值固定为0xCAFEBABE，不会改变。意思是cafe babe（本应该是Baby，但是16进制没有y，程序员的浪漫~）

> 文件版本号

+ 紧接着魔数的4个字节存储的是Class文件的版本号
+ 不同版本的Java编译器编译的Class文件对应的版本是不一样的。目前，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件，但是低版本的Java虚拟机不能执行由高版本编译器生成的Class文件。否则JVM会抛出java.lang.UnsupportedClassVersionError异常。（向下兼容）

> 常量池

+ 常量池对于Class文件中的字段和方法解析也有着至关重要的作用
+ 常量池表项中，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放

### 怎么去打开字节码文件

由于.class文件是一个16进制文件，EXE等二进制/16进制文件一般是不能被记事本等纯文本编辑打开的，否则会乱码

+ 要想查看这些16进制到底长什么样子，去下载`UltraEdit`这个工具，用这个打开文件后，右击选择16进制编辑，文件的数据就全变成16进制显示了,因为没什么作用（都是数字），我就不做展示了

要想查看二进制文件的16进制的内容 ，这里给出两种方法的详细步骤

> javap命令——javap是是JDK自带的**反汇编器**
>
> 根据class字节码文件，反解析出当前类对应的code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息

**辨析反汇编和反编译**

> + 反汇编：把目标代码转为汇编代码的过程,也可说是把机器语言转为汇编语言代码,低级转高级的意思
>
> + 反编译：显示.class文件的*Java*源代码

进入字节码文件目录，执行以下命令，即可在命令行得到字节码文件的信息

```
javap -v Demo.class
```

![image-20220413162815490](D:\桌面\P_picture_cahe\image-20220413162815490.png)

> `jclasslib`工具会更方便,IDEA有这个插件，可以生成可视化字节码文件（阅读体验好一点）

第一步，下载插件

![image-20220413153123344](D:\桌面\P_picture_cahe\zPUxq9GZ4O8eNpB.png)

第二步，打开字节码文件并且在IDEA中找到图中选项

![image-20220413161943426](https://s2.loli.net/2022/04/13/OoIv3p7dseQzB9C.png)

你可以在这里看到字节码文件的全部信息

![image-20220413162246756](https://s2.loli.net/2022/04/13/YlFSJzT2ecAZ7Oa.png)



## 类加载器

任意一个类，都由**加载它的类加载器**和这个**类本身**一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都有一个独立的类名称空间

**如图所示，在.class文件->JVM->最终成为元数据模板被执行引擎使用，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色**

![image-20220411225511956](https://s2.loli.net/2022/04/14/HhcZ7NpK1DtyQg8.png)

### 类加载器的分类

> **JVM将类加载器划分为两大类**

1. **启动类加载器**

   只有一个(Bootstrap ClassLoader)

2. **自定义类加载器（User-Defined ClassLoader)**

   **Java虚拟机规范定义：**将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器

**系统提供了 3 种类加载器**

> **1、启动类加载器(`Bootstrap ClassLoader`)** 

+ 加载`JAVA_HOME/jre/lib`目录下的类库，如`rt.jar`、`resources.jar`、`charsets.jar`等。当然通过配置`-Xbootclasspath` 参数可以指定这些jar包的加载路径

  > **Jdk11以后默认不安装Jre,所以你在本地文件库中找不到这个jar包（可以自行安装寻找）**
  >
  > ![image-20220414141652032](https://s2.loli.net/2022/04/14/ec9xsJBFpG2WDah.png)

+ 不继承`java.lang.ClassLoader`,没有父加载器

+ 这个加载器是 C++ 编写的，**无法直接引用**，随着 JVM 启动，是虚拟机自身的一部分

+ 出于安全考虑，Bootstrap启动类加载器只加载包名为java,javax,sun等开头的类

> **2、扩展类加载器(`Extension ClassLoader`)** 

+ 主要用于加载 `lib/ext` 目录下的 jar 包和 .class 文件。同样的，通过系统变量 `java.ext.dirs` 可以指定这个目录
+ 这个加载器是个 Java 类，继承自` URLClassLoader`(由启动类加载器加载进内存的)
+ 可以直接引用

> **3、应用程序类加载器**(`Application ClassLoader`)也叫做系统类加载器

+ 用户自定义的 Java 类的默认加载器，一般用来加载 classpath 下的其他所有 jar 包和 .class 文件，用户编写的代码，会首先尝试使用这个类加载器进行加载
+ 可以直接引用

> **自定义类加载器**
>
> 开发人员可以通过继承抽象类`java.lang.ClassLoader`类的方式，实现自己的类加载器，以满足一些特殊的需求，例如：
>
> + 隔离加载类
>
> - 修改类加载的方式
>
> - 扩展加载源
>
> - 防止源码泄漏（加壳）

类加载器的关系如图所示，**这些加载器并不是实际意义上的继承关系，也就是父加载器并不是它的父类，只是它自己的上一层加载器的意思**

![image-20220413200427260](https://s2.loli.net/2022/04/14/tEODf4hwcrT8Pos.png)

> **注**
>
> + **`.class`文件存在于本地硬盘上,ClassLoader只负责class文件的加载，至于它是否可以运行，则由ExecutionEngine决定**
> + **当`.class`文件被加载到JVM中，被称为DNA元数据模板，放在方法区**
>

### 代码层面分析

jdk版本为11

> 获取应用程序类加载器

```java
ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
//jdk.internal.loader.ClassLoaders$AppClassLoader@2437c6dc
System.out.println(systemClassLoader);
```

> 获取拓展类加载器

```java
ClassLoader extClassLoader = systemClassLoader.getParent();
//jdk.internal.loader.ClassLoaders$PlatformClassLoader@58ceff1
System.out.println(extClassLoader);
```

> 获取引导类加载器

String类是由Bootstrap类加载器加载的，返回的是个null，是因为Bootstrap类加载器是由C++来实现的，java里面并没有一个class和它直接对应，所以返回null，所以当我们看到null值的时候，代表类加载器已经到头了

```java
ClassLoader bootStrapClassloader = extClassLoader.getParent();
//null--->(Bootstrap ClassLoader)
System.out.println(bootStrapClassloader);
```

## 双亲委派机制

### 什么是双亲委派模型

双亲委派模型是描述类加载器之间的层次关系。它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。（父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码）

### 工作过程

**总结：交给父类加载，不行才自己加载**

1. 当我们通过自定义类加载器加一个类的时候，会先去自定义类加载器的缓存当中找（如果已经加载过一遍了就会存到缓存当中），如果从缓存中找到了就直接返回，没找到就委托父加载器找。
2. 应用类加载器收到委托后去它的缓存当中找，找到就返回，没找到就委托它的父加载器
3. 扩展类加载器收到委托后去它的缓存当中找，找到就返回，没找到就委托它的父加载器
4. 启动类加载器收到委托后去它的缓存当中找，找到就返回，没找到就委派它的子加载器去寻找class文件并加载
5. 扩展类加载器收到委派命令后尝试去加载，找到就返回，没找到就委派它的子加载器去寻找class文件并加载
6. 应用类加载器收到委派命令后尝试去加载，找到就返回，没找到就委派它的子加载器去寻找class文件并加载
7. 自定义加载器收到委派命令后尝试去加载，找到就返回，没找到就报错（classnotfound）

### 为什么需要双亲委派?

1. 避免类的重复加载

   当父加载器已经加载过某一个类时，子加载器就不会再重新加载这个类

2. 保护程序安全，防止核心API被随意篡改 

- 如自定义类：java.lang.String（报错：阻止创建 java.lang开头的类）

![image-20220414133435965](https://s2.loli.net/2022/04/14/CxOrNnEHUGa9Z2y.png)

### 双亲委派机制

双亲委派模型对于保证Java程序的稳定运作很重要，但它的实现并不复杂

**实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass()方法之中**



==源码阅读：jdk11-->ClassLoader类-->loadClass方法（与Jdk8的实现方式有很大的不同）==

```java
		@Override
        protected Class<?> loadClass(String cn, boolean resolve)
            throws ClassNotFoundException
        {
            // for compatibility reasons, say where restricted package list has
            // been updated to list API packages in the unnamed module.
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                int i = cn.lastIndexOf('.');
                if (i != -1) {
                    sm.checkPackageAccess(cn.substring(0, i));
                }
            }
			//调用父加载器
            return super.loadClass(cn, resolve);
        }
```

### 如何破坏双亲委派机制

**首先来学习一下ClassLoader这个类**

> 主要方法
>
> - *loadClass()* 就是主要进行类加载的方法，默认的双亲委派机制就实现在这个方法中。
> - *findClass()* 根据名称或位置加载.class字节码
> - *definclass()* 把字节码转化为Class

**如何破坏双亲委派机制**

> 1. **需要自定义一个类加载器，并且需要破坏双亲委派原则时，我们会重写loadClass方法**
> 2. **想定义一个自己的类加载器，并且要遵守双亲委派模型，那么可以继承ClassLoader，并且在findClass中实现你自己的加载逻辑**
>
> JDK1.2之后已不再提倡用户直接覆盖loadClass()方法，而是建议把自己的类加载逻辑实现到findClass()方法中，因为在loadClass()方法的逻辑里，如果父类加载器加载失败，则会调用自己的findClass()方法来完成加载

### 破坏双亲委派机制的案例

1. 在双亲委派出现之前

   由于双亲委派模型是在JDK1.2之后才被引入的，而在这之前已经有用户自定义类加载器在用了。所以，这些是没有遵守双亲委派原则的。

2. JNDI、JDBC等需要加载SPI接口实现类的情况

3. 为了实现热插拔热部署工具

   为了让代码动态生效而无需重启，实现方式时把模块连同类加载器一起换掉就实现了代码的热替换。

4. 第四种时Tomcat等web容器的出现

5. 第五种时OSGI、Jigsaw等模块化技术的应用。

#### 案例一：Tomcat破坏双亲委派机制

Tomcat是web容器，那么一个web容器可能需要部署多个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的

> **问题**

如果采用默认的双亲委派类加载机制，那么是无法加载不同版本的相同的类

> **解决方式**
>
> Tomcat破坏双亲委派原则，提供隔离的机制，为每个web容器单独提供一个WebAppClassLoader加载器

Tomcat的类加载机制：为了实现隔离性，优先加载 Web 应用自己定义的类，所以没有遵照双亲委派的约定，每一个应用自己的类加载器——WebAppClassLoader负责加载本身的目录下的class文件，加载不到时再交给CommonClassLoader加载，这和双亲委派刚好相反

#### 案例二：JDBC破坏双亲委派机制

[推荐阅读：Java如何在底层操作数据库](https://blog.csdn.net/Night__breeze/article/details/120653466?spm=1001.2014.3001.5502)

我们日常开发中，大多数时候会通过API的方式调用Java提供的那些基础类，这些基础类时被Bootstrap加载的。但是，调用方式除了API之外，还有一种SPI的方式,首先来看一下这两个方式

> `API` Application Programming Interface
> 大多数情况下，都是实现方来制定接口并完成对接口的不同实现，调用方仅仅依赖却无权选择不同实现。
> `SPI` Service Provider Interface
> 如果是调用方来制定接口，实现方来针对接口来实现不同的实现。调用方来选择自己需要的实现方

如典型的JDBC服务，我们通常通过以下方式创建数据库连接：

```java
Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mysql", "root", "1234");
```

在以上代码执行之前，DriverManager会先被类加载器加载，因为java.sql.DriverManager类是位于rt.jar下面的 ，所以他会被根加载器加载。

类加载时，会执行该类的静态方法。其中有一段关键的代码是：

```java
ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);
```

这段代码，会尝试加载classpath下面的所有实现了Driver接口的实现类

> **问题**

**DriverManager是被根加载器加载的，那么在加载时遇到以上代码，会尝试加载所有Driver的实现类，但是这些实现类基本都是第三方提供的，根据双亲委派原则，第三方的类不能被根加载器加载。**

> **解决方案**
>
> JDBC中通过引入ThreadContextClassLoader（线程上下文加载器，默认情况下是AppClassLoader）的方式破坏了双亲委派原则。

==JDK11源码阅读 --> ServiceLoader类 --> load方法==

```java
	@CallerSensitive
    public static <S> ServiceLoader<S> load(Class<S> service) {
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        return new ServiceLoader<>(Reflection.getCallerClass(), service, cl);
    }
```

解释：第一行，获取当前线程的线程上下⽂类加载器 AppClassLoader，⽤于加载 classpath 中的具体实现类

## 类加载的过程（生命周期）

> 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.**Class**对象用来封装**类在方法区(元空间)内的数据结构**
>
> 规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中。
>
> **`.Class`文件**也并非特指某个存在于具体磁盘中的文件，而应当是一串**二进制字节流**，无论其以何种形式存在，包括但不限于磁盘文件、 网络、数据库、内存或者**动态产生**等

**类加载过程概述**

类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括以下 7 个阶段

（其中验证、准备、解析 3 个阶段统称为连接）

**这七个阶段发生的顺序如图所示**

![image-20220413171313692](https://s2.loli.net/2022/04/13/HPfFCv41ILMTqwx.png)

### 加载阶段

:a: **注意辨析这个加载和类加载的区别，这个是类加载的第一个阶段**

什么是需要开始类第一个阶段“加载”，虚拟机规范没有强制约束，这点交给虚拟机的具体实现来自由把控

> 加载阶段虚拟机需要完成以下 3 件事情

1. 通过一个类的全限定名来获取定义此类的二进制字节流。(可以从硬盘上的字节码文件读取，也可以从网络中读取，或者动态代理生成等等)
2. 将这个字节流所代表的 静态存储结构 转化为**方法区**的**instanceKlass**。
3. 在**堆**中生成一个代表这个类的**InstanceMirrorKlass**对象，作为方法区的这个类的各种数据的访问入口

**为什么有了instanceKlass还需要有InstanceMirrorKlass？**

> 主要是为了安全性考虑，jvm的开发者不希望直接暴露instanceKlass里面类的全部元信息，而且作为Java程序员也没有必要去知道这些信息，使用权限标识符去控制就已经足够了。
>
> 如果暴露了，那么黑客可以使用C++或者JNI来写一些漏洞或者外挂，来绕过Java本身的权限判断，就会有很大的安全问题了

**注：静态属性是存储在堆里面，也就是挂载到InstanceMirrorKlass上面的**



类被加载后，就进入连接阶段。连接就是将经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去

### 连接阶段

#### 验证（Verify）

+ **这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。**
+ **验证阶段主要检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证**

验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段，因为验证阶段只有通过或者不通过的差别，只要通过了验证，其后就对程序运行期没有任何影响了

如果程序运行的全部代码(包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码)都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用`-Xverify:none` 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间

#### 准备（Prepare）

+ 为类变量分配内存并且设置该类变量的默认初始值，即零值
+ 这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化
+ 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中

#### 解析（Resolve）

+  将常量池内的符号引用转换为直接引用的过程。

- 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。
- 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
- 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info等

### 初始化阶段

- 初始化阶段就是执行类构造器方法`<clinit>()`的过程。

- 此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。

- 构造器方法中指令按语句在源文件中出现的顺序执行。

- `<clinit>()`不同于类的构造器。（关联：构造器是虚拟机视角下的<init>()）

- 若该类具有父类，JVM会保证子类的`<clinit>()`执行前，父类的`<clinit>()`已经执行完毕。

- 虚拟机必须保证一个类的`<clinit>()`方法在多线程下被同步加锁



# 三、运行时数据区

## 运行时数据区



### 3.1.1. 概述



本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段





当我们通过前面的：类的加载-> 验证 -> 准备 -> 解析 -> 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区





内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。





我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品





我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁







Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。



灰色的为单独线程私有的，红色的为多个线程共享的。即：



- 每个线程：独立包括程序计数器、栈、本地栈。

- 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）





每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。



### 线程



线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。



当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。



操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。



### 3.1.3. JVM系统线程



如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用`public static void main(String[] args)`的main线程以及所有这个main线程自己创建的线程。



这些主要的后台系统线程在Hotspot JVM里主要是以下几个：



- 虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括"stop-the-world"的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。

- 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。

- GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。

- 编译线程：这种线程在运行时会将字节码编译成到本地代码。

- 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。



##







## JVM运行时数据区域

### 





## Java内存区域与内存溢出异常







## 垃圾回收器与内存分配策略







## 虚拟机性能监控、故障处理工具



## 调优案例分析与实战































