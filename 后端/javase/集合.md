## 前言

> 集合框架的定义

在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合，而**集合框架**就是这些集合对象的抽象

> 为什么需要集合框架？
>

[推荐阅读[Why We Need Collection Framework in Java? - GeeksforGeeks]](https://www.geeksforgeeks.org/why-we-need-collection-framework-in-java/)

[推荐阅读[Java SE 8文档-集合框架概述 - doc.oracle]](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html)

框架是一组提供现成架构的类和接口。为了实现一个新特性或一个类，不需要定义一个框架。然而，一个最佳的面向对象的设计总是包含一个具有类集合的框架，这样所有的类都执行相同类型的任务

在集合框架（或 JDK 1.2 之前）引入之前，对 Java 对象（或集合）进行分组的标准方法是数组或向量，或哈希表。所有这些集合都没有通用接口。因此，尽管所有集合的主要目的是相同的，但所有这些集合的实现都是独立定义的，它们之间没有关联。而且，用户很难记住每个集合类中存在的所有不同的方法、语法和构造函数。

**简而言之，我们需要各种不同类型的集合类来处理不同的数据，集合框架是为了便于处理一组类似且需要灵活操作的数据**

> 一些不建议使用的集合类&接口

由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用

- `Hashtable`：一种线程安全的`Map`实现；
- `Vector`：一种线程安全的`List`实现；
- `Stack`：基于`Vector`实现的`LIFO`的栈。

还有一小部分接口是遗留接口，也不应该继续使用：

- `Enumeration<E>`：已被`Iterator<E>`取代。

## 集合的分类

所有集合类都位于`java.util`包下，所以当使用集合框架的时候需要进行导包

```
单列集合根接口：java.util.Collection
双列集合根接口：java.util.Map
```

> 理解Collectioin和Map这两个接口

Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类

**Collection**

![image-20210424161458520](https://i.loli.net/2021/04/24/hn4CDSYmXpjc3iG.png)

**Map**

![image-20210424183218036](https://i.loli.net/2021/04/24/IXsWqBELxKcowp8.png)

> Java的`java.util`包主要提供了以下三种类型的集合

- `List`集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问
- `Set`集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）
- `Map`集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value

> 集合框架图

![](https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif)

通过集合框架图来理清楚集合框架中各个类与接口的关系

## Collection

> Collection集合结构

![image-20210422181830481](https://i.loli.net/2021/04/22/u1vGwbUTFZqHcaC.png)



> Collection中可以存放什么元素

+ 没有使用泛型之前，Collection可以存储任何Object的子类型
  使用泛型之后，Collection只能存储某个具体的类型

+ 集合任何时候存储的都是引用，它不能存基本数据类型

> Collection特性

+ 集合中的对象比较需要重写equals方法，否则比较的是对象地址
+ 不同的集合底层对应不同的数据结构
+ 所有的集合类和集合接口都在java.util包下
+ 集合也是一个对象，也有一个内存地址指向它

> Collection集合常用方法

```java
	boolean add(E e);  //像集合中添加元素
    boolean remove(E e);  //删除集合中某个元素
    void clear(); //清空集合中所有元素
	boolean contains(E e) //判断集合中是否包含某个元素
    boolean isEmpty(); ///判断集合是否为空
	int size(); //获取集合的长度
	Object[] toArray(); //将集合转变成一个数组
```

### Iterator

Iterator也就是迭代器，是Collection通用的遍历集合的方式

+ Iterator迭代器是一个接口，无法直接使用，需要使用Iterator接口的实现类对象，但Iterator获取实现类的方式比较特殊————Collection接口中有一个方法，叫`iterator()`,这个方法返回的就是迭代器的实现类对象

> 迭代器的用法

```java
//迭代器中的常用方法
boolean hasNext();  //如果仍有元素可以迭代，则返回true
Object next(); //返回迭代的下一个元素
```

示例代码

```java
public class CollecionTest {
    //Collection中的remove和contains方法底层需要重写equals方法
    @Test
    public void test01() {
        Collection<String> obj = new ArrayList<String>();
        obj.add("first");
        obj.add("second");
        obj.add("third");
        Iterator<String> it = obj.iterator();
        while (it.hasNext()) {
            System.out.println(it.next());
            //obj.remove("first");//并发异常：java.util.ConcurrentModificationException
            it.remove();//使用迭代器来删除删除迭代器指向的当前元
        }
        System.out.println(obj.isEmpty());
    }
}
```

**注:在迭代集合元素的过程中，不能调用对象的remove方法删除元素，否则会出现异常**

### Collections工具类

java.util.Collections是集合工具类，用来对集合进行操作

> 常用方法

```java
public static <T> boolean addAll(Collecrion<T> c,T... elements) //像集合中添加一些元素
public static void shuf	fle(<List<?> list) //打乱集合顺序
public static <T> void sort(List<T> list)  //将集合中元素按照默认规则排序
public static <T> void sort(List<T> list,Comparator<? super T>) //将及各种元素按照指定规则排序
```

示例代码

```java
public class CollectionsTest {
    //测试集合工具类的方法
    public void test() {
        List list = new ArrayList();
        //addAll方法添加多个元素
        Collections.addAll(list, "e", "d", "c", "b", "a");
        System.out.println(list);
        Collections.shuffle(list);//shuffle方法打乱集合顺序
        System.out.println(list);
        //对集合排序
        Collections.sort(list);//默认规则一般是升序
        System.out.println(list);
    }

    @Test
    public void run2() {
        //对自定义类person排序，需要实现comparable接口并重写方法
        ArrayList<Person> person = new ArrayList<>();
        person.add(new Person("张三", 27));
        person.add(new Person("李四", 79));
        person.add(new Person("王五", 20));
        Collections.sort(person);
        System.out.println(person);
    }

    @NoArgsConstructor
	@AllArgsConstructor
	@Data
    class Person implements Comparable<Person> {
        String name;
        int age;

        @Override
        public int compareTo(Person o) {
            //排序规则
            //this - 参数 => 升序，反之降序
            return o.getAge() - this.getAge();
        }
        
    @Test
    public void run3() {
    /*
    comparator和comparable的区别
        comparable：自己和参数比较，需要实现comparable接口并且重写方法
        comparator
     */
        ArrayList<Person> person = new ArrayList<>();
        person.add(new Person("张三", 27));
        person.add(new Person("李四", 79));
        person.add(new Person("王五", 20));

        Collections.sort(person, new Comparator<Person>() {
            @Override
            public int compare(Person o1, Person o2) {
                //升序排序
                return o1.getAge() - o2.getAge();
            }
        });
    }
}
```

在Collection集合类中，`List`是最基础的一种集合：它是一种有序列表

因此我们先学习List

### List

`java.util.List` 接口 extends Collection接口，从以下几点开始走进List

> 构建一个List

```java
		List<Object> objects = new ArrayList<>();
        List<Object> objects = new LinkedList<>();
```

除了使用`ArrayList`和`LinkedList`，我们还可以通过`List`接口提供的`of()`方法，根据给定元素快速创建`List`：

```
List<Integer> list = List.of(1, 2, 5);
```

但是`List.of()`方法不接受`null`值，如果传入`null`，会抛出`NullPointerException`异常

注：

**1、`List`的`add`方法接受null值**

**2、`List.of()`，它返回的是一个只读`List`。对只读`List`调用`add()`、`remove()`方法会抛出	`UnsupportedOperationException`**

> Jdk9对集合添加的优化
>

List接口，Set接口，Map接口：里面添加了一个静态的方法of，可以给集合一次性添加多个元素

使用前提：

​		集合中存储的元素个数已经确定，不再改变

注意事项：

1. 只适用于List，Map，Set，不适用于接口的实现类
2. of方法的返回值是一个不能改变的集合，集合不能使用add,put等方法添加元素，会抛出异常
3. Set和Map接口在调用of方法时，不能有重复的元素，否则回抛出异常



> List接口的特性

+ 有序的集合，存储元素和取出元素的顺序是一致的
+ 有索引，有带索引的方法
+ `List`接口允许我们添加重复的元素，即`List`内部的元素可以重复

> List接口带索引的方法（特有）
>

```java
	public void add(int index,E element); //将元素添加到指定位置
	public E get(int index) // 返回指定位置元素
    public E remove(int index) //移除列表指定位置的元素并将其作为返回值
    public E set(int index,E element) //用指定元素替换集合中指定位置的元素，返回更新前的元素  
```

**注：调用`List`的`contains()`、`indexOf()`这些方法，放入的元素需要实现`equals()`方法**

**总结一下equals()方法的正确编写方法：**
1、先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；
2、用instanceof判断传入的待比较的Object是不是当前类型，如果是，继续比较，否则，返回false；
3、对引用类型用Objects.equals()比较，对基本类型直接用==比较。
使用Objects.equals()比较两个引用类型是否相等的目的是省去了判断null的麻烦。两个引用类型都是null时它们也是相等的。

> List集合的遍历方式

+ 普通for循环

  ```java
  		for (int i=0; i<list.size(); i++) {
              String s = list.get(i);
              System.out.println(s);
          }
  ```

+ foreach

+ 迭代器

**注：操作索引的时候一定要防止索引越界异常**

1. IndexOutOfBoundException : 索引越界异常，一般是集合
2. ArrayIndexOutofBoundException: 数组索引越界异常
3. StringIndexOutOfBoundException 字符串索引越界异常

> List与Array的转换

**一、将List变为Array**

​	第一种是调用`toArray()`方法直接返回一个`Object[]`数组，这种方法会丢失类型信息，所以实际应用很少。

```java
Object[] array = list.toArray();
```

​	第二种方式是给`toArray(T[])`传入一个类型相同的`Array`，`List`内部自动把元素复制到传入的`Array`中

```java
 Integer[] array = list.toArray(new Integer[3]);
```

​	更简洁的一种做法

```java
Integer[] array = list.toArray(new Integer[list.size()]);
//函数式的写法
Integer[] array = list.toArray(Integer[]::new);
```

**二、把Array变为List---`List.of（）`方法**

```java
List<Integer> list = List.of(array);
```

> ArrayList与LinkedList

|                     | ArrayList    | LinkedList           |
| :------------------ | :----------- | -------------------- |
| 获取指定元素        | 速度很快     | 需要从头开始查找元素 |
| 添加元素到末尾      | 速度很快     | 速度很快             |
| 在指定位置添加/删除 | 需要移动元素 | 不需要移动元素       |
| 内存占用            | 少           | 较大                 |

通常情况下，我们总是优先使用`ArrayList`

#### ArrayList(重点)

> 特性

+ ArrayList底层采用了数组 Object[]
+ 元素增删慢，查询快
+ ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制

+ ArrayList 继承了 AbstractList ，并实现了 List 接口

+ ArrayList是非线程安全的

  jdk5.0开始 集合的工具类[Collections]里面提供一个方法`synchronizedList`可以将线程不安全的ArrayList集合变成线程安全的集合对象,于是Vector渐渐被淘汰了

> 构造方法

```java
	ArrayList list = new ArrayList(int 数组空间大小);
	ArrayList list = new ArrayList();//数组默认开辟10块空间

	集合会自动扩容：
			jdk6.0及之前	x * 3 / 2 + 1
							10 -> 16 -> 25....

			jdk7.0及之后	x + (x >> 1)
							10 -> 15 -> 22....

		在项目开发的时候 尽量避免扩容：
			1：创建一个更大的新的数组对象
			2：将老数组里面的元素复制到新数组里面
			3：改变引用指向
			4：回收老数组对象
			5：继续添加元素
```

> 常用方法

```java
public boolean add(E e); //像集合当中添加元素，参数类型和泛型一致

注：对于ArrayList集合来说，add添加一定成功，所以返回值可用可不用，但是对于其他集合来说，add添加动作不一定成功，所以返回值需要使用
    
public E get(int index); //从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素

public E remove(int index);//从集合中删除元素，参数是索引编号

public int size(); //获取集合的尺寸长度，返回值是集合中包含的元素个数,不是获取集合的容量
```

#### LinkedList

底层是链表结构

元素增删快，查询慢

LinkedList语法和ArrayList一样

### Set集合

#### Set基础

> Set特性

Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是仅有一个。由于Set接口的特殊性，**所有传入Set集合中的元素都必须不同**，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致`e1.equals(e2)==true`，则必定会产生某些问题

> Set常用实现类

+ 散列集HashSet
+ 链式散列集LinkedHashSet
+ 树形集TreeSet

> 此外需要说明一点，在set接口中的不重复是有特殊要求的
>
> HashSet存储自定义类型的元素时，需要重写hashCode和equals方法，建立自己的比较方式，才能保证hashSet中集合的对象唯一

举一个例子：对象A和对象B，本来是不同的两个对象，正常情况下它们是能够放入到Set里面的，但是如果对象A和B的都重写了hashcode和equals方法，并且重写后的hashcode和equals方法是相同的话。那么A和B是不能同时放入到Set集合中去的，也就是Set集合中的去重和hashcode与equals方法直接相关。

为了更好地理解，请看下面的例子：

```java
public class Test{ 
public static void main(String[] args) { 
     Set<String> set=new HashSet<String>(); 
     set.add("Hello"); 
     set.add("world"); 
     set.add("Hello"); 
     System.out.println("集合的尺寸为:"+set.size()); 
     System.out.println("集合中的元素为:"+set.toString()); 
  } 
}
```

运行结果：

```
集合的尺寸为:2
集合中的元素为:[world, Hello]
```

分析：由于String类中重写了hashcode和equals方法，用来比较指向的字符串对象所存储的字符串是否相等。所以这里的第二个Hello是加不进去的。



#### Set集合实现类

**HashSet**

> HashSet特性

+ HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。
+ HashSet 允许有 null 值。
+ 不保证元素的顺序(这里所说的没有顺序是指：元素插入的顺序与输出的顺序不一致
+ HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。
+ HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能
+ HashSet的实现方式大致如下，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象。

> HashSet使用和理解中容易出现的误区

**a.HashSet中存放null值。**HashSet中是允许存入null值的，但是在HashSet中仅仅能够存入一个null值。

**b.HashSet中存储元素的位置是固定的。**HashSet中存储的元素的是无序的，这个没什么好说的，但是由于HashSet底层是基于Hash算法实现的，使用了hashcode，所以HashSet中相应的元素的位置是固定的。

**c.必须小心操作可变对象**（`Mutable Object`）。如果一个Set中的可变元素改变了自身状态导致`Object.equals(Object)=true`将导致一些问题

**LinkedHashSet**

> 特性

LinkedHashSet继承自HashSet，其底层是**基于LinkedHashMap来实现的**，有序，非同步。LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，**LinkedHashSet将会以元素的添加顺序访问集合的元素**

**TreeSet**

> 特性

TreeSet是一个有序集合，其底层是基于TreeMap实现的，非线程安全。TreeSet可以确保集合元素处于排序状态。**TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。**当我们构造TreeSet时，若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。

> 注意：TreeSet集合不是通过hashcode和equals函数来比较元素的.它是通过compare或者compareTo函数来判断元素是否相等.compare函数通过判断两个对象的id，相同的id判断为重复元素，不会被加入到集合中

#### 遍历Set集合

基本上HashSet、[LinkedHashSet](https://so.csdn.net/so/search?q=LinkedHashSet&spm=1001.2101.3001.7020)和TreeSet采用的遍历方式都是一样的，不同的是三者输出结果的顺序不同：

1. for循环遍历方式；
2. Iterator迭代器遍历方式；
3. foreach遍历方式，Java8以后出现的，没有add、remove等操作

```java
	// for循环遍历方式
    for (String s : set){
        System.out.println(s);
    }
    // 迭代器遍历方式
    Iterator<String> ite = set.iterator();
    while(ite.hasNext()){
        System.out.println(ite.next());
    }
    // foreach遍历方式
    set.forEach(ites->{
        System.out.println(ites);
    });
```



## Map

Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它**不能存在相同的key值，当然value值可以相同**

> Map集合结构

![image-20220124222131189](https://s2.loli.net/2022/01/24/B4y3ANnbmOix2EL.png)

> java.util.Map<K,V>集合特点

1. Map是<K,V>集合双列集合最顶层的接口，一个元素包含两个值<key,value>
2. key不允许重复，value允许重复
3. key和value一一对应
4. key和value都是引用数据类型
5. key和value都是存储对象的内存地址

常用实现类

+ HashMap

+ LinkedHashMap

> Map集合常用的方法

```java
public V put(K key, V value) //像Map集合中添加键值对
public V remove(Object key) //删除指定键所对应的键值对，并返回V值
public V get(Object key) //返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。
boolean containsKey(Object key) //判断Map中是否包含某个Key
boolean containsValue(Object value) //判断Map中是否包含某个Value
void clear() //清空Map集合
boolean isEmpty() //判断Map集合是否为空
public Set(K) keySet() //获取Map集合所有的key,存储到set集合中
int Size() //返回此映射中的键-值映射关系数。
Collection<V> values() //返回此映射中包含的值的 Collection 视图。
public Set<Map.Entry<K,V>> entrySet() //获取到Map集合中所有键值对对象的集合(Set集合)===Map集合全部转换成Set集合，Set集合中的元素类型是:Map.Entry
```

> TODO:掌握map.put(k,v)和map.get(key)的实现原理，掌握哈希表
>
> 在存取过程中，都是先调用hashCode方法再调用equals方法，equals方法有可能调用，也有可能不调用

### Map集合的遍历

```java
//推荐使用的方式----entrySet方法
for (Map.Entry<Integer, String> node : map.entrySet()) {
    System.out.println(node.getKey() + "=" + node.getValue());
}

//foreach
for (String s : map.values()) {
    System.out.println(s).;
}

//keySet方法
//将map集合中所有的key取出来存储到一个set集合中，遍历set集合键找值
for (Integer key : map.keySet()) {
    String s = map.get(key);
    System.out.println(s);
}
```

### HashMap（重点）

> 特性

以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构

> 实现方式

底层是哈希表，查询快

1. jdk1.8之前 ： 数组 + 单向链表
2. jdk1.8之后 ： 数组 + 单项链表/红黑树（链表长度超过8）

> HashMap存储自定义类型键值对

由于map集合要保证key的唯一性，但**实际需求中可能相同的key值代表不同的对象**，因此，需要重写hashCode和equals方法

```java
package 集合.Map接口.Hashable类;

import org.junit.Test;

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

public class HashMap存储自定义键值对 {
    public void test01() {
    //key使用String类型，已经重写hashCode和equals方法
    //结果==>北京的两个人不能并存
    //value：Person类型，是可重复的
        HashMap<String,Person> map = new HashMap<>();
        map.put("北京",new Person("张三",18));
        map.put("上海",new Person("李四",18));
        map.put("广州",new Person("王五",18));
        map.put("北京",new Person("赵六",18));
        //遍历
        for(Map.Entry<String,Person> m: map.entrySet()){
            System.out.println(m.getKey()+"--->"+m.getValue());
        }
    }
    @Test
    public void test02(){
        //key使用Person类型，已经重写hashCode和equals方法
        //结果==>北京的两个人可以并存
        //value：String类型，是可重复的
        HashMap<Person,String> map = new HashMap<>();
        map.put(new Person("张三",18),"北京");
        map.put(new Person("李四",18),"上海");
        map.put(new Person("王五",18),"广州");
        map.put(new Person("赵六",18),"北京");
        //遍历
        for(Map.Entry<Person,String> m: map.entrySet()){
            System.out.println(m.getKey()+"--->"+m.getValue());
        }
    }
}
	@NoArgsConstructor
	@AllArgsConstructor
	@Data
class Person{
    private String name;
    private int age;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &&
                Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```

### LinkedHashMap

> 特性

LinkedHashMap

1. LinkedHashMap是HashMap的一个子类，底层是哈希表+链表（保证**集合有序**，多一层链表保证了迭代的顺序，如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。
2. **LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。**此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
3. LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。
4. 根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。

> 注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能，但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。

### TreeMap

**TreeMap 是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点。**TreeMap存储时会进行排序的，会根据key来对key-value键值对进行排序，其中排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。

**自然排序：**TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。

**定制排序：**定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。

TreeMap判断两个元素相等的标准：两个key通过`compareTo()`方法返回0，则认为这两个key相等。

如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的`equals()`方法，TreeMap中判断相等的标准是：两个key通过`equals()`方法返回为true，并且通过`compareTo()`方法比较应该返回为0

### Hashtable

+ since jdk1.0
+ 线程安全，单线程，速度慢
+ 和vector一样，在jdk1.2版本后被更先进的集合取代了（HashMap,ArrayList)
+ 但是Hashtable的子类Properties仍然使用
+ Properties集合是唯一一个和IO流相结合的集合
+ Hashtable 不允许键值对为空，但是HashMap允许

### 异同点的比较

> 比较HashTable与HashMap

相同点：

- 都实现了`Map、Cloneable、java.io.Serializable`接口。
- 都是存储"键值对(key-value)"的散列表，而且都是采用拉链法实现的。

不同点：

**（1）历史原因：**HashTable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。

**（2）同步性：**HashTable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。

**（3）对null值的处理：**HashMap的key、value都可为null，HashTable的key、value都不可为null 。

**（4）基类不同：**HashMap继承于AbstractMap，而Hashtable继承于Dictionary。

- Dictionary是一个抽象类，它直接继承于Object类，没有实现任何接口。Dictionary类是JDK 1.0的引入的。虽然Dictionary也支持“添加key-value键值对”、“获取value”、“获取大小”等基本操作，但它的API函数比Map少；而且Dictionary一般是通过Enumeration(枚举类)去遍历，Map则是通过Iterator(迭代M器)去遍历。然而由于Hashtable也实现了Map接口，所以，它即支持Enumeration遍历，也支持Iterator遍历。
- AbstractMap是一个抽象类，它实现了Map接口的绝大部分API函数；为Map的具体实现类提供了极大的便利。它是JDK 1.2新增的类。

**（5）支持的遍历种类不同：**HashMap只支持Iterator(迭代器)遍历。而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历



> HashMap、Hashtable、LinkedHashMap和TreeMap比较

Hashmap 是一个最常用的Map，它根据键的HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。**HashMap最多只允许一条记录的键为Null；允许多条记录的值为Null；HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap；可能会导致数据的不一致。**如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。

Hashtable 与 HashMap类似，不同的是：**它不允许记录的键或者值为空；它支持线程的同步**，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢。



LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，**当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。**



如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。**LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链表**。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。对于LinkedHashMap而言，它继承与HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。



**TreeMap实现SortMap接口，内部实现是红黑树。**能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。



一般情况下，我们用的最多的是HashMap，HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。

TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。

## Properties

在编写应用程序的时候，经常需要读写配置文件。例如，用户的设置

```
# 上次最后打开的文件:
last_open_file=/data/hello.txt
# 自动保存文件的时间间隔:
auto_save_interval=60
```

配置文件的特点是，它的Key-Value一般都是`String`-`String`类型的，因此我们完全可以用`Map<String, String>`来表示它。

因为配置文件非常常用，所以Java集合库提供了一个`Properties`来表示一组“配置”。由于历史遗留原因，`Properties`内部本质上是一个`Hashtable`，但我们只需要用到`Properties`自身关于读写配置的接口。

### 读取配置文件

用`Properties`读取配置文件非常简单。Java默认配置文件以`.properties`为扩展名，每行以`key=value`表示，以`#`课开头的是注释。以下是一个典型的配置文件：

```
# setting.properties
last_open_file=/data/hello.txt
auto_save_interval=60
```

可以从文件系统读取这个`.properties`文件：

```
String f = "setting.properties";
Properties props = new Properties();
props.load(new java.io.FileInputStream(f));

String filepath = props.getProperty("last_open_file");
String interval = props.getProperty("auto_save_interval", "120");
```

可见，用`Properties`读取配置文件，一共有三步：

1. 创建`Properties`实例；
2. 调用`load()`读取文件；
3. 调用`getProperty()`获取配置。

调用`getProperty()`获取配置时，如果key不存在，将返回`null`。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。

也可以从classpath读取`.properties`文件，因为`load(InputStream)`方法接收一个`InputStream`实例，表示一个字节流，它不一定是文件流，也可以是从jar包中读取的资源流：

```
Properties props = new Properties();
props.load(getClass().getResourceAsStream("/common/setting.properties"));
```



如果有多个`.properties`文件，可以反复调用`load()`读取，后读取的key-value会覆盖已读取的key-value：

```
Properties props = new Properties();
props.load(getClass().getResourceAsStream("/common/setting.properties"));
props.load(new FileInputStream("C:\\conf\\setting.properties"));
```

上面的代码演示了`Properties`的一个常用用法：可以把默认配置文件放到classpath中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置。

`Properties`设计的目的是存储`String`类型的key－value，但`Properties`实际上是从`Hashtable`派生的，它的设计实际上是有问题的，但是为了保持兼容性，现在已经没法修改了。除了`getProperty()`和`setProperty()`方法外，还有从`Hashtable`继承下来的`get()`和`put()`方法，这些方法的参数签名是`Object`，我们在使用`Properties`的时候，不要去调用这些从`Hashtable`继承下来的方法。

### 写入配置文件

如果通过`setProperty()`修改了`Properties`实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用`store()`方法：

```
Properties props = new Properties();
props.setProperty("url", "http://www.liaoxuefeng.com");
props.setProperty("language", "Java");
props.store(new FileOutputStream("C:\\conf\\setting.properties"), "这是写入的properties注释");
```

### 编码

早期版本的Java规定`.properties`文件编码是ASCII编码（ISO8859-1），如果涉及到中文就必须用`name=\u4e2d\u6587`来表示，非常别扭。从JDK9开始，Java的`.properties`文件可以使用UTF-8编码了。

不过，需要注意的是，由于`load(InputStream)`默认总是以ASCII编码读取字节流，所以会导致读到乱码。我们需要用另一个重载方法`load(Reader)`读取：

```
Properties props = new Properties();
props.load(new FileReader("settings.properties", StandardCharsets.UTF_8));
```

就可以正常读取中文。`InputStream`和`Reader`的区别是一个是字节流，一个是字符流。字符流在内存中已经以`char`类型表示了，不涉及编码问题。

### 小结

Java集合库提供的`Properties`用于读写配置文件`.properties`。`.properties`文件可以使用UTF-8编码。

可以从文件系统、classpath或其他任何地方读取`.properties`文件。

读写`Properties`时，注意仅使用`getProperty()`和`setProperty()`方法，不要调用继承而来的`get()`和`put()`等方法。



























