# 一、缓存的概念


在服务端编程当中，缓存主要是指将数据库的数据加载到内存中，之后对该数据的访问都在内存中完成，从而减少了对数据库的访问，解决了高并发场景中数据库容易成为性能瓶颈的问题；以及基于内存的访问速度高于磁盘的访问速度的原理（数据库读取数据一般需要从磁盘读取），提高了数据的访问速度和程序性能。

 

根据缓存是否与应用进程属于同一进程，可以将内存分为本地缓存和分布式缓存。本地缓存是在同一个进程内的内存空间中缓存数据，数据读写都是在同一个进程内完成；而分布式缓存是一个独立部署的进程并且一般都是与应用进程部署在不同的机器，故需要通过网络来完成分布式缓存数据读写操作的数据传输。

 

# 二、本地缓存

## 本地缓存的优缺点

 

**1. 访问速度快，但无法进行大数据存储**
本地缓存相对于分布式缓存的好处是，由于数据不需要跨网络传输，故性能更好，但是由于占用了应用进程的内存空间，如 Java 进程的 JVM 内存空间，故不能进行大数据量的数据存储。

 

**2. 集群的数据更新问题**
与此同时，本地缓存只支持被该应用进程访问，一般无法被其他应用进程访问，故在应用进程的集群部署当中，如果对应的数据库数据，存在数据更新，则需要同步更新不同部署节点的本地缓存的数据来包保证数据一致性，复杂度较高并且容易出错，如基于 Redis 的发布订阅机制来同步更新各个部署节点。

 

**3. 数据随应用进程的重启而丢失**
由于本地缓存的数据是存储在应用进程的内存空间的，所以当应用进程重启时，本地缓存的数据会丢失。所以对于需要持久化的数据，需要注意及时保存，否则可能会造成数据丢失。

 

适用场景

所以本地缓存一般适合于缓存只读数据，如统计类数据。或者每个部署节点独立的数据，如长连接服务中，每个部署节点由于都是维护了不同的连接，每个连接的数据都是独立的，并且随着连接的断开而删除。如果数据在集群的不同部署节点需要共享和保持一致，则需要使用分布式缓存来统一存储，实现应用集群的所有应用进程都在该统一的分布式缓存中进行数据存取即可。

 

## 本地缓存的实现

 

缓存一般是一种key-value的键值对数据结构，所以需要使用字典数据结构来实现，在 Java 编程中，常用的字典实现包括 HashMap 和 ConcurretHashMap。


与此同时，本地缓存由于需要被不同的服务端线程并发读写，故需要保证线程安全。由于 HashMap 不是线程安全的，而 ConcurrentHashMap 是线程安全的，故一般会使用 ConcurrentHashMap 来作为 Java 编程中的本地缓存实现。除此之外，也有其他更加智能的本地缓存实现，如可以定时失效，访问重新加载等特性，典型实现包括 Google 的 guava 工具包的 Cache 实现，这些也是线程安全的。

 

# 三、分布式缓存

 

## 分布式缓存的优缺点

 

**1. 支持大数据量存储，不受应用进程重启影响**
分布式缓存由于是独立部署的进程，拥有自身独立的内存空间，不会受到应用进程重启的影响，在应用进程重启时，分布式缓存的数据依然存在。同时对于数据量而言，由于不需要占用应用进程的内存空间，并且一般支持以集群的方式拓展，故可以进行大数据量的数据缓存。

 

**2. 数据集中存储，保证数据一致性**
当应用进程采用集群方式部署时，集群的每个部署节点都通过一个统一的分布式缓存进行数据存取操作，故不存在本地缓存中的数据更新问题，保证了不同节点的应用进程的数据一致性问题。

 

**3. 数据读写分离，高性能，高可用**
分布式缓存一般支持数据副本机制，可以实现读写分离，故可以解决高并发场景中的数据读写性能问题。并且由于在多个缓存节点冗余存储数据，提高了缓存数据的可用性，避免某个缓存节点宕机导致数据不可用问题。

 

**4. 数据跨网络传输，性能低于本地缓存**
由于分布式缓存是独立部署的进程，并且一般都是与应用进程位于不同的机器，故需要通过网络来进行数据传输，这样相对于本地缓存的进程内部的数据读取操作，性能会较低。

 

## 分布式缓存的实现
分布式缓存的典型实现包括 MemCached 和 Redis。

 

**MemCached**

 

MemCached 相对于本地缓存的主要差别是以独立进程方式存在，数据集中存储，数据不随应用程序的重启而丢失。而 key-value 键值对的 value 也是一个简单的对象类型，即 value 可以是任意格式的数据，如简单的数字、字符串、对象等，也可以是文件、图像、视频等复杂格式的数据，但是不支持数据结构的特性。

 

所以 MemCached 进程相当于是在内存维护了一个非常大的哈希表来存储数据，对应的数据操作复杂度都是 O(1)，即常量级别，这也是 MemCached 高性能的一个实现方式，键值对存取速度都非常快。

 

**Redis**

 

Redis 是在此基础上，更一步丰富了key-value 键值对的 value 的数据结构类型，即可以在 Redis 中完成 value 的相关数据操作，如 Set 集合去重、有序集合 ZSet 实现数据排序等，这样就不需要在应用程序额外进行这些操作，实现了开箱即用。并且 Redis 是单线程的，不存在并发数据读写的线程安全问题，以及更重要的是保证的数据读写操作的顺序性。

 

除此之外，Redis 支持主从同步（读写分离）、集群分片拓展、数据持久化等特性，这也是 MemCached 不支持的。所以在高并发场景并且数据能够容忍极端情况下的少量丢失，或者说丢失后可以恢复，如通过日志或者重新计算等， Redis 也可以作为数据库来使用，提高高并发场景中的访问性能。