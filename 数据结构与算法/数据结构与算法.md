Java数据结构与算法学习笔记整合



# Java数据结构与算法

**写在开头**





**参考书籍以及一些摘抄**

> 《算法》第四版
>
> 

> 《大话数据结构》
>
> 

> 《labuladong的算法小抄》
> 数据结构的基本存储方式就是链式和顺序两种，基本操作就是增删查改，遍历方式无非迭代和递归      
>
> 刷算法题建议从「树」分类开始刷，结合框架思维，把这几十道题刷完，对于树结构的理解应该就到位了。这时候去看回溯、动规、分治等算法专题，对思路的理解可能会更加深刻一些

感谢Open Source

# 数据结构篇

## 开篇

### 数据结构和算法是什么

+ 程序=数据结构+算法
+ 数据（data）结构（structure）是一门研究 **组织数据方式** 的学科，有了编程语言也就有了数据结构，**学好数据结构可以编写出更加漂亮，更加有效率的代码**--百度百科

+ 学好数据结构，是为学习算法打好一个基础，但是并不代表你就能写出一个好的算法

### 数据结构的存储方式

**数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储）**，所有的数据结构都是基于这两种基本数据结构实现的

这句话怎么理解，不是还有散列表、栈、队列、堆、树、图等等各种数据结构吗？

我们分析问题，⼀定要有递归的思想，⾃顶向下，从抽象到具体。你上来就列出这么多，那些都属于「上层建筑」，⽽**数组和链表才是「结构基础」**。因为那些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作，API 不同而已。
⽐如说「队列」、「栈」这两种数据结构既可以使⽤链表也可以使⽤数组实现。用数组实现，就要处理扩容缩容的问题；⽤链表实现，没有这个问题，但需要更多的内存空间存储节点指针

> 综上，数据结构种类很多，甚⾄你也可以发明⾃⼰的数据结构，但是底层存储无非数组或者链表，⼆者的优缺点如下

数组由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须⼀次性分配够，所以说数组如果要扩容，需要重新分配⼀块更⼤的空间，再把数据全部复制过去，时间复杂度 O(N)；⽽且你如果想在数组中间进⾏插⼊和删除，每次必须搬移后⾯的所有数据以保持连续，时间复杂度 O(N)。 

链表因为元素不连续，而是靠指针指向下⼀个元素的位置，所以不存在数组 的扩容问题；如果知道某⼀元素的前驱和后驱，操作指针即可删除该元素或 者插⼊新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据⼀个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必 须存储指向前后元素位置的指针，会消耗相对更多的储存空间 	

### 数据结构的基本操作

**对于任何数据结构，其基本操作无非遍历 + 访问，再具体⼀点就是：增删查改** 

数据结构种类很多，但它们存在的⽬的都是在不同的应⽤场景，尽可能高效地增删查改。话说这不就是数据结构的使命么？ 如何遍历 + 访问？我们仍然从最⾼层来看，各种数据结构的**遍历 + 访问无非两种形式：线性的和非线性的**

### 为什么需要数据结构和算法

**用稀疏数组的例子来说明其高效性**

为什么需要稀疏数组?

Q:用二维数组存储一个五子棋盘,因为该二维数组的很多值是默认值 0, 因此记录了很多没有意义的数据.我们尝试用稀疏数组来解决这个问题

![image-20211026183706531](https://i.loli.net/2021/10/26/sZRODgWHaBJt9rz.png)



> 【Algorithm】稀疏数组
>
> 当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。
> **稀疏数组的处理方法是**:
> 1) 记录数组一共有几行几列，有多少个不同的值
> 2) 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而 缩小程序的规模

![image-20211026191906154](https://i.loli.net/2021/10/26/KMPuCUtEVD35q2z.png)



```java
public class 稀疏数组 {
    public static void main(String[] args) {
        //初始化棋盘
        int[][] arr = new int[8][8];
        //给棋盘赋值,1表示黑子，2表示白子，默认值0表示无子
        arr[1][2] = 1;
        arr[6][4] = 2;
        //打印原始数据
        稀疏数组.printChessboard(arr);
        // 将二维数组转稀疏数组
        //先遍历二维数组 得到非0数据的个数
        int sum = 0;
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                if (arr[i][j] != 0) {
                    sum++;
                }
            }
        }
        //创建一个稀疏数组
        //第0行记录原数组的大小和数据的个数
        int[][] sparseArr = new int[sum + 1][3];
        sparseArr[0][0]=8;
        sparseArr[0][1]=8;
        sparseArr[0][2]=sum;
        //写入稀疏数组
        int count =0;//记录第几个非0数据
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                if (arr[i][j] != 0) {
                    count++;
                    sparseArr[count][0] = i;//记录行
                    sparseArr[count][1] = j;//记录列
                    sparseArr[count][2] = arr[i][j];//记录值
                }
            }
        }
        //打印稀疏数组
        System.out.println("==============");
        稀疏数组.printChessboard(sparseArr);
        //恢复稀疏数组并展示
        System.out.println("================");
        //初始化数组
        int arr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];
        //赋值
        for (int i = 1; i < sparseArr.length; i++) {
            arr2[sparseArr[i][0]][sparseArr[i][1]]=sparseArr[i][2];
        }
        //打印
        稀疏数组.printChessboard(arr2);
    }

    //输出二维数组
    public static void printChessboard(int[][] arr) {
        for (int[] row : arr) {
            for (int data : row) {
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }
    }
}
```



**为此，我们开始学习数据结构**

> 学习算法前要首先搞定数据结构，之前提到数组和链表才是结构基础，数组我们已经非常熟悉了，因此先来学习链表这个数据结构

## 数组与链表

### 相关概念

> 数组

作为任何一门程序语言都不可或缺的数组，这里就不多做介绍，推荐阅读以下链接加深自己对数组的了解

[深入理解 Java 数组](https://dunwu.github.io/javacore/basics/java-array.html#_1-%E7%AE%80%E4%BB%8B)

> 为什么要有链表 —— 链表在进行循环遍历时效率不高，但是插入和删除时优势明显

顺序存储结构是有缺点的,最大的缺点就是插入和删除时需要移动大量元素,这显然就需要耗费时间,能不能想办法解决呢?
要解决这个问题，我们就得考虑一下导致这个问题的原因
为什么当插入和删除时,就要移动大量元素,仔细分析后,发现原因就在于相邻两元素的存储位置也具有邻居关系。它们在内存中的位置也是挨着的,中间没有空隙,当然就无法快速介入,而删除后当中就会留出空隙，自然需要弥补，问题就出在这里  



为了解决数组插入和删除操作需要移动大量元素的缺点，我们使用链式结构存储数据。链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址

==>**链式存储结构诞生了！**链表以节点的方式来存储，每个节点包含数据域，指针域





### 常用的三类链表

#### 单向链表

**单链表的遍历方向单一【只能从链头一直遍历到链尾】**

**单向链表常用操作**



#### 双向链表

> 单向链表的缺点分析

+ 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。
+ 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除节点，总是找到 temp,temp 是待删除节点的前一个节点

#### 环形链表

**定义**





**应用**

> Josephu（约瑟夫问题）



### 遍历问题

**数组遍历框架**

```java
void traverse(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
    // 迭代访问 arr[i]
    }
}
```

**链表遍历框架**

```java
/* 基本的单链表节点 */
class ListNode {
    int val;
    ListNode next;
}
void traverse(ListNode head) {
    for (ListNode p = head; p != null; p = p.next) {
    // 迭代访问 p.val
    }
}
void traverse(ListNode head) {
    // 递归访问 head.val
    traverse(head.next)
}
```

### 链表刷题

> 单向链表的反转

```java

```

> 合并有序链表

[力扣21题](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```java
	public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
            //用递归写这个题
            if(list1==null) return list2;
            if(list2==null) return list1;
            //这个说明当另一个串为空的时候，这个两个串合并就是
            // list(空).next = list(非空)
            if(list1.val<list2.val){
                list1.next = mergeTwoLists(list1.next,list2);
                return list1;
            }else{
                list2.next = mergeTwoLists(list1,list2.next);
                return list2;
                }
        }
```



> 







> 栈与队列
>
> 栈是限定仅在表尾进行插入和删除操作的线性表
>
> 队列是允许在一端进行擦混入操作，而在另一端进行删除操作的线性表

## 栈(Stack)

### 相关概念

> 栈的定义





> 怎样去操作栈

+ 栈式限定仅在栈顶进行插入和删除操作的线性表
+ 我们把允许插入和删除的一端称为栈顶（top)，另一端称为栈底（bottom)，不含任何数据元素的栈称为空栈。
+ 栈又称为后进先出 （Last In First Out)的线性表,简称LIFO结构
+ 出栈操作称之为 `pop`, 入栈的操作称之为 `push`

### 栈的应用场景

1)子程序的调用:在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中
2)处理递归调用:和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中
3)表达式的转换与求值(实际解决)
4)二叉树的遍历
5)图形的深度优先(depth—first)搜索法

### 栈的顺序存储与链式存储

使用数组模拟

### Java中的Stack类

```java
//Vector是线程安全的
public class Stack<E> extends Vector<E> {
	...
}
```

它通过5个操作对类vector进行扩展，允许将向量视为堆栈。

 它提供了通常的 `push` 和 `pop` 操作，以及取栈顶点的 `peek` 方法、测试堆栈是否为空的 `empty` 方法、在堆栈中查找项并确定到栈顶距离的 `search` 方法。 

```java
 E push(E item) 
          把项压入栈顶部。 
 E pop() 
          移除栈顶部的对象，并作为此函数的值返回该对象。 
 E peek() 
          查看栈顶部的对象，但不从堆栈中移除它。 
 boolean empty() 
          测试栈是否为空。  
 int search(Object o) 
          返回对象在栈中的位置，以 1 为基数。
```

### 后缀表达式（逆波兰表达式）

**引子**

以9+(3-1)×3+10÷2为例，这是一个非常简单的题目，心算也可以很快算出是20。可就这么简单的题目，计算器却不能在一次输入后马上得出结果,很是不方便。

这里面的困难就在于乘除在加减的后面，却要先运算，而加入了括号后，就变得更加复杂。不知道该如何处理。但仔细观察后发现，括号都是成对出现的，有左括号就一定会有右括号，对于多重括号，最终也是完全嵌套匹配的。这用栈结构正好合适，只有碰到左括号，就将此左括号进栈,不管表达式有多少重括号，反正遇到左括号就进栈而后面出现右括号时，就让栈顶的左括号出栈,期间让数字运算，这样，最终有括号的表达式从左到右巡查一遍，栈应该是由空到有元素,最终再因全部匹配成功后成为空栈的结果

但对于四则运算,括号也只是当中的一部分,先乘除后加减使得问题依然复杂,如何有效地处理它们呢?

==》引出了后缀表达式

**后缀表达式**：又称为逆波兰表达式，运算符位于操作数之后，使用计算机处理问题，我们一般转化为后缀表达式

以`(3+4）* 5 - 6`为例，对应的后缀表达式为 `3 4 + 5 * 6 -`

**后缀表达式如何求值**

> 规则:**从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字弹出，进行运算，运算结果进栈，一直到最终获得结果**

**中缀表达式转换为后缀表达式**

我们把平时所用的标准四则运算表达式,即`9+(3-1)×3+10÷2`叫做中缀表达式。因为所有的运算符号都在两数字的中间，现在我们的问题就是中缀到后缀的转化，进而方便计算机的运算

附代码：

```java
//将String类型的中缀表达式转为一个List<String>
    public static List<String> toListString(String expression) {
        String[] s = expression.split("");
        ArrayList<String> strings = new ArrayList<>();
        for (String ele : s) {
            strings.add(ele);
        }
        return strings;
    } 	
//中缀表达式转后缀表达式
    public static List<String> toSuffixExpression(String str) {
        //得到中缀表达式
        List<String> list = toListString(str);
        System.out.println("中缀表达式为"+list);
        //后缀表达式
        List<String> suffixString = new ArrayList<>();
        //符号栈
        Stack<String> stack = new Stack<String>();
       	//按照规则遍历中缀表达式
        for (String item : list) {
            if (item.matches("\\d+")) {//如果是一个数，进入后缀表达式
                suffixString.add(item);
            } else if (item.equals("(")) {//左括号入栈
                stack.push(item);
            } else if (item.equals(")")) {
                //如果是右括号，则持续出栈操作，知道碰到左括号为止
                while (!stack.peek().equals("(")) {//栈顶元素!=(
                    suffixString.add(stack.pop());
                }
                stack.pop();
            } else {//判断item优先级
                //小于等于栈顶元素优先级，弹栈并存入后缀表达式
                while (stack.size() != 0 && Operation.getValue(stack.peek()) >= Operation.getValue(item)) {
                    suffixString.add(stack.pop());
                }
                //将item压入栈中
                stack.push(item);
            }
        }
        //遍历中缀表达式完成后，将栈中剩余的数据弹出栈加入后缀表达式
        while (stack.size() != 0) {
            suffixString.add(stack.pop());
        }
        return suffixString;
    }
```

> 规则:**从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分;若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号，则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。**

### 栈的应用 - 逆波兰计算器

> 输入一个算式 , 将其转换为后缀表达式，计算其结果
>
> 1、支持小数
>
> 2、支持小括号和多位数整数
>
> 3、使用数据结构 -- 栈

输入样例

`9+(3-1)×3+10÷2`    

输出样例

逆波兰表达式为 ：`9 3 1-3 * + 1 0 2 / +`

计算结果为 ：20

代码

TODO:**1、多位数 2、小数**

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

public class PolandNotationDemo {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        //从键盘输入获取中缀表达式
        String expression = sc.nextLine();
        //输出后缀表达式
        List<String> strings = toSuffixExpression(expression);
        //计算机对后缀表达式进行求值
        int calculate = calculate(strings);
        System.out.println("逆波兰表达式为 :" + strings);
        System.out.println("计算结果为" + calculate);
    }


    //中缀表达式转后缀表达式(todo:只是一位数)
    public static List<String> toSuffixExpression(String str) {
        //得到中缀表达式
        List<String> list = toListString(str);
        System.out.println("中缀表达式为" + list);
        //后缀表达式
        List<String> suffixString = new ArrayList<>();
        //符号栈
        Stack<String> stack = new Stack<String>();
        /**
         * 从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分;
         * 若是符号，则判断其与栈顶符号的优先级，
         * 是右括号或优先级低于栈顶符号(乘除优先加减)
         * 则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止
         */
        for (String item : list) {
            if (item.matches("\\d+")) {//如果是一个数，进入后缀表达式
                suffixString.add(item);
            } else if (item.equals("(")) {//左括号入栈
                stack.push(item);
            } else if (item.equals(")")) {
                //如果是右括号，则持续出栈操作，知道碰到左括号为止
                while (!stack.peek().equals("(")) {//栈顶元素!=(
                    suffixString.add(stack.pop());
                }
                stack.pop();
            } else {//判断item优先级
                //小于等于栈顶元素优先级，弹栈并存入后缀表达式
                while (stack.size() != 0 && Operation.getValue(stack.peek()) >= Operation.getValue(item)) {
                    suffixString.add(stack.pop());
                }
                //将item压入栈中
                stack.push(item);
            }
        }
        //遍历中缀表达式完成后，将栈中剩余的数据弹出栈加入后缀表达式
        while (stack.size() != 0) {
            suffixString.add(stack.pop());
        }
        return suffixString;
    }

    //判断是不是一个运算符
    public static boolean isOper(char val) {
        return val == '+' || val == '-' || val == '*' || val == '/';
    }

    //将中缀表达式转为一个List<String>
    public static List<String> toListString(String expression) {
        String[] s = expression.split("");
        //获得了一个数组，但是两位数的还没进去
        ArrayList<String> strings = new ArrayList<>();
        for (String ele : s) {
           strings.add(ele);
        }
        return strings;
    }

    //计算后缀表达式
    public static int calculate(List<String> list) {
        Stack<String> stack = new Stack<>();

        for (String item : list) {
            if (item.matches("\\d+")) {//如果是一个数字
                stack.push(item);
            } else {
                int res = -1;
                int num1 = Integer.parseInt(stack.pop());
                int num2 = Integer.parseInt(stack.pop());
                if (item.equals("+")) {
                    res = num1 + num2;
                } else if (item.equals("-")) {
                    res = num1 - num2;
                } else if (item.equals("*")) {
                    res = num1 * num2;
                } else if (item.equals("/")) {
                    res = num1 / num2;
                } else {
                    throw new RuntimeException("运算符有误");
                }
                stack.push("" + res);

            }
        }

        return Integer.parseInt(stack.pop());
    }
}

class Operation {
    private static int ADD = 1;
    private static int SUB = 1;
    private static int MUL = 2;
    private static int DIV = 2;

    //返回对应的优先级数字
    public static int getValue(String operation) {
        int result = 0;

        switch (operation) {
            case "+":
                result = ADD;
                break;
            case "-":
                result = SUB;
                break;
            case "*":
                result = MUL;
                break;
            case "/":
                result = DIV;
                break;
            default:
                System.out.println("非法运算符");
                break;
        }
        return result;
    }
}

```

### 小结

**从刚才的推导中你会发现，要想让计算机具有处理我们通常的标准(中缀)表达式的能力,最重要的就是两步:**

**1．将中缀表达式转化为后缀表达式(栈用来进出运算的符号)**

**2．将后缀表达式进行运算得出结果(栈用来进出运算的数字)**



## 队列

### 队列的定义

+ 队列（queue)是只允许在一端进行插入操作，在另一端进行删除操作的线性表
+ 队列是一个有序列表，可以用 数组 或 链表 来实现

### 数组模拟队列

```java
//使用数组模拟队列
public class ArrayQueueDemo {
    private int maxsize;//代表队列最大容量
    private int front; //指向队列头的引用，指向队列头的前一个位置，跟输出有关
    private int rear; //指向队列尾的引用，指向队列尾的数据（包含队列尾），跟输入有关
    private int[] arr;//模拟队列中的数据

    //创建队列的构造器
    public ArrayQueueDemo(int arrMaxSize) {
        this.maxsize = arrMaxSize;
        arr = new int[maxsize];
        front = -1;//指向队列头，指向队列头的前一个位置 跟输出有关
        rear = -1;//指向队列尾，指向队列尾的数据（包含队列尾）跟输入有关
    }
}
```

**队列的CRUD**

```java
//判断队列是否满
public boolean isFull() {
        return rear == maxsize - 1;
    }

//判断队列是否为空
public boolean isEmpty() {
        return rear == front;
    }

//添加数据到队列
public void addQueue(int n) {
        if (isFull()) {
            System.out.println("队列已满");
            return;
        }
        rear++;//让rear后移
        arr[rear] = n;
    }

 //获取队列数据
    public int getQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列为空不能取出");
        }
        front++;
        return arr[front];
    }
```

### 数组模拟环形队列

![image-20211027212217839](D:\桌面\P_picture_cahe\image-20211027212217839.png)

```java
public class CircleArrayQueue {

    private int maxsize;//表示最大容量
    private int front; //队列头
    private int rear; //队列尾
    private int[] arr;//该数据用于存放数据，模拟队列

    //创建队列的构造器
    public 用数组模拟环形队列(int arrMaxSize) {
        this.maxsize = arrMaxSize;
        arr = new int[maxsize];
        front = 0;//跟输出有关
        rear = 0;//跟输入有关
    }
}
```

**环形队列的CRUD**

```java
    //判断队列是否已满 (rear+1) % maxSize == front ==>队列满
    public boolean isFull() {
        return (rear+1) % maxsize == front;
    }

    //判断队列是否为空 rear == front
    public boolean isEmpty() {
        return rear == front;
    }

    //添加数据到队列
    public void addQueue(int n) {
        if (isFull()) {
            System.out.println("队列已满");
            return;
        }
        arr[rear] = n;
        //******
        rear = (rear+1)%maxsize;
    }

    //获取队列数据
    public int getQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列为空不能取出");
        }
        //先保存front中保存的临时变量
        int value = arr[front];
        //相当于数组越界后取整
        front = (front+1)%maxsize;
        return value;
    }

    //求出环形队列有效数据
    public int siza(){
        return (rear + maxsize - front) % maxsize;
    }

    //打印队列
    public void printQueue(){
        if (isEmpty()){
            System.out.println("队列为空");
        }
        //从front开始遍历，需要遍历多少个？
        for (int i = 0; i < arr.length; i++) {
            System.out.printf("arr[%d]=%d\n",i,arr[i]);
        }
    }
```

### 顺序存储的优缺点





## 树

### 基础概念

> 树的定义

树的基本概念难度都不大，为了节省篇幅，我这里简单过一下。

+ 树是一种非线性数据结构。

+ 树结构的基本单位是节点。
+ 节点之间的链接，称为分支（branch）。
+ 节点与分支形成树状，结构的开端，称为根（root），或根结点。
+ 根节点之外的节点，称为子节点（child）。
+ 没有链接到其他子节点的节点，称为叶节点（leaf）。

如下图是一个典型的树结构

![image-20220310163822929](https://s2.loli.net/2022/03/10/DG35Fehl8Ji2g7f.png)

### 二叉树

二叉树是我们做算法题最常见的一种树，因此花大篇幅学习它，要花大量时间重点掌握

```java
//二叉树可以这样表示
Node {
    value: any; // 当前节点的值
    left: Node | null; // 左儿子
    right: Node | null; // 右儿子
}
```

> 二叉树的分类

**二叉树**

+ 每个节点最多只能有两个子节点的树称为二叉树
+ 二叉树的结点分为左节点和右节点

**满二叉树**

+ 当二叉树的所有叶子节点都在最后一层，并且节点总数为 2^n-1(n为层数)，则称之为满二叉树

**完全二叉树**

+ 所有叶子节点在最后一层或者倒数第二层，而且最后一层叶子在左边连续，倒数第二层叶子在右边连续，则称为完全二叉树

### 二叉树的遍历

**整个树的专题只有一个中心点，那就是树的遍历，大家务必牢牢记住，而树的遍历又可以分为两个基本类型，分别是深度优先遍历和广度优先遍历。这两种遍历方式并不是树特有的，但却伴随树的所有题目。值得注意的是，这两种遍历方式只是一种逻辑而已，因此理论可以应用于任何数据结构**



**二叉树的深度优先遍历分为**：前序遍历，中序遍历，后序遍历

+ 前序遍历：先输出父节点，再遍历左子树和右子树

+ 中序遍历：先遍历左子树，再输出父节点，再遍历右子树

+ 后序遍历：先遍历左子树，在遍历右子树，最后输出父节点

tips:可以看父节点的输出顺序来判断遍历方式



> 前序遍历

递归实现

```java
	 public static void accessTree(TreeNode root) {
        if (root==null)
            return;
        System.out.println(root.val);
        accessTree(root.left, res);
        accessTree(root.right, res);        
    }
```

循环实现-需要借助到栈这个数据结构

```java
//使用循环遍历二叉树
    public static List<Integer> anotherWay(TreeNode root) {
        ArrayList<Integer> res = new ArrayList<>();
        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();
        while (root != null || !stack.isEmpty()) {//
            while (root != null) {//找到没有左节点的那个结点
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            res.add(root.val);
            root = root.right;
        }
        return res;
    }
```



> 中序遍历

```java
public static void accessTree(TreeNode root) {
        if (root == null)
            return;
        accessTree(root.left,res);
    	System.out.println(root.val);
        accessTree(root.right,res);
    }
```

循环实现-需要借助到栈这个数据结构

```java
//循环的方式遍历
    public static List<Integer> anotherWay(TreeNode root) {
        ArrayList<Integer> res = new ArrayList<>();
        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();
        while (root != null || !stack.isEmpty()) {//
            while (root != null) {//找到没有左节点的那个结点
                System.out.println(root.val);
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            root = root.right;
        }
        return res;
    }
```

> 后序遍历

```java
public static void accessTree(TreeNode root) {
        if (root == null)
            return;
        accessTree(root.left, res);
        accessTree(root.right, res);
        System.out.println(root.val);
    }
```

循环实现

```java
 	public static List<Integer> anotherWay(TreeNode root) {
        ArrayList<Integer> res = new ArrayList<>();
        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();
        TreeNode prevAccess = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            if (root.right == null || root.right == prevAccess) {
                System.out.println(root.val);
                prevAccess = root;
                root = null;
            } else {
                stack.push(root);
                root = root.right;
            }
        }
        return res;
    }
```

### 树刷题

> 二叉树的最大深度

```java
	//求一个二叉树的最大深度
    public int helper(TreeNode left,TreeNode right){
        if(left.next==null&&right.next==null)
            return 0;
        return Math.max(helper(left.right,left.left),helper(right.left,right.right))+1;
    }
```

> 平衡二叉树

这种方法效率比较低，思考一下如何优化代码

```java
	public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        } else {
             return Math.abs(height(root.left) - height(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);
        }
    }

    //求一个二叉树的最大深度
    public int height(TreeNode root){
        if(root==null)
            return 0;
        return Math.max(height(root.left),height(root.right))+1;
    
    }
```

> 翻转二叉树

```java
public class 翻转二叉树 {
    public TreeNode invertTree(TreeNode root) {
        if (root == null)
            return root;
        invertTree(root.left);
        invertTree(root.right);
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        return root;
    }
}
```







## 图

### 基础概念

> 图的定义

图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：**G(V,E)**，其中，**G**表示一个图，**V**是图G中顶点的集合，**E**是图G中边的集合。

> 在图中需要注意的是

（1）线性表中我们把数据元素叫元素，树中将数据元素叫结点，**在图中数据元素，我们则称之为顶点（Vertex）**。

（2）线性表可以没有元素，称为空表；树中可以没有节点，称为空树；但是，**在图中不允许没有顶点**（有穷非空性）。

（3）线性表中的各元素是线性关系，树中的各元素是层次关系，而**图中各顶点的关系是用边来表示**（边集可以为空）。

> 图的基本概念

+ 有向图

  如果图中任意两个顶点之间的边都是有向边（简而言之就是有方向的边），则称该图为有向图（Directed graphs）。

![image-20220302144628583](https://s2.loli.net/2022/03/02/C5lxNoHgMXITka6.png)

+ 无向图

  如果图中任意两个顶点之间的边都是无向边（简而言之就是没有方向的边），则称该图为无向图

  ![image-20220302144649935](https://s2.loli.net/2022/03/02/G9yTk2qRAOcJanS.png)

+ 顶点的度

  顶点Vi的度（Degree）是指在图中与Vi相关联的边的条数。对于有向图来说，有入度（In-degree）和出度（Out-degree）之分，有向图顶点的度等于该顶点的入度和出度之和

+ 路径

  在无向图中，若从顶点Vi出发有一组边可到达顶点Vj，则称顶点Vi到顶点Vj的顶点序列为从顶点Vi到顶点Vj的路径

+ 带权图

  有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权

  ![image-20220302145405014](https://s2.loli.net/2022/03/02/ULxewlTI9OiRd6h.png)

### 为什么需要图

前面我们学了线性表和树
线性表局限于一个直接前驱和一个直接后继的关系
树也只能有一个直接前驱也就是父节点
当我们需要表示多对多的关系时， 这里我们就用到了图

### 图的存储结构

图的存储结构除了要存储图中的各个顶点本身的信息之外，还要存储顶点与顶点之间的关系，因此，图的结构也比较复杂。常用的图的存储结构有邻接矩阵和邻接表等

> 二维数组表示---邻接矩阵

图的**邻接矩阵**（Adjacency Matrix）存储方式是**用两个数组来表示图**。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息

+ 无向图

  无向图的边数组是一个对称矩阵

![image-20220302152448487](https://s2.loli.net/2022/03/02/egpWmAfdDGC62Mk.png)

+ 有向图

![image-20220302152513755](https://s2.loli.net/2022/03/02/8jN6AF2VOHQPMtf.png)

+ 带权图

  和无向图差不多，就是加了权值，两个顶点之间无边的话距离是∞

![image-20220306133918819](https://s2.loli.net/2022/03/06/U3CynB4dreD7mgu.png)

由于存在n个顶点的图需要n*n个数组元素进行存储，**当图为稀疏图时，使用邻接矩阵存储方法将会出现大量0元素，这会造成极大的空间浪费**。这时，可以考虑使用邻接表表示法来存储图中的数据

> 链表表示---邻接表

首先，回忆我们在线性表时谈到，顺序存储结构就存在预先分配内存可能造成存储空间浪费的问题，于是引出了链式存储的结构。同样的，我们也可以考虑对边或弧使用链式存储的方式来避免空间浪费的问题。       

邻接表由**表头节点**和**表节点**两部分组成，图中每个顶点均对应一个存储在数组中的表头节点。如果这个表头节点所对应的顶点存在邻接节点，则把邻接节点依次存放于表头节点所指向的单向链表中。

+ 无向图

![image-20220302152615119](https://s2.loli.net/2022/03/02/CaPMjHtDLOUVIqx.png)

+ 有向图

若是有向图，邻接表结构是类似的，但要注意的是有向图由于有方向的。因此，有向图的邻接表分为出边表和入边表（又称逆邻接表）

![image-20220302152754685](D:\桌面\P_picture_cahe\image-20220302152754685.png)

![image-20220302152805962](D:\桌面\P_picture_cahe\image-20220302152805962.png)





### 图的遍历

> 图的遍历是和树的遍历类似，我们希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次,这一过程就叫做图的遍历（Traversing Graph)。
>
> 树的遍历我们谈到了四种方案，应该说都还好,毕竟根结点只有一个，遍历都是从它发起，其余所有结点都只有一个双亲。可图就复杂多了，因为它的任一顶点都可能和其余的所有顶点相邻接，**极有可能存在沿着某条路径搜索后,又回到原顶点，而有些顶点却还没有遍历到的情况**。因此我们需要在遍历过程中把访问过的顶点打上标记，以避免访问多次而不自知。具体办法是设置一个**访问数组 visited[n]**,n是图中顶点的个数，初值为0，访问过后设置为1。这其实在小说中常常见到，一行人在迷宫中迷了路，为了避免找寻出路时屡次重复，所以会在路口用小刀刻上标记。对于图的遍历来说，如何避免因回路陷入死循环,就需要科学地设计遍历方案，通常有两种遍历次序方案:它们是深度优先遍历和广度优先遍历。

#### DFS



# 算法篇

   



常用算法思想+具体问题分析+Java代码实现

## 算法的时间复杂度与空间复杂度

**度量一个程序(算法)效率的两种方法**

1、 事后统计的方法
这种方法可行, 但是有两个问题：一是需要实际运行测试该算法；二是依赖于计算机的硬件、软件等环境因素
2、 事前估算的方法
通过分析某个算法的<u>时间复杂度</u>来判断哪个算法更优

### 时间复杂度

> **定义**



> **计算时间复杂度的方法**

1. 用常数1代替运行时间中的所有加法常数
2. 修改后的运行次数函数中，只保留最高阶项
3. 去除最高阶项的系数

> **常见的时间复杂度**

![image-20211102180341692](https://i.loli.net/2021/11/02/6W2ViPoesFErmAf.png)

常见的算法时间复杂度由小到大依次为: 

O(1) < O(logN) < O(n) < O(nlogN) < O(n^2) < O(n^3) < O(n^k) < O(2^n)

随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低

### 空间复杂度

空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度



### 二者的关系

对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。算法的时间复杂度和空间复杂度合称为算法的复杂度。



## 排序算法

> 各算法复杂度、稳定性和适用场景

- **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
- **不稳定**：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
- **时间复杂度**: 对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
- **空间复杂度：**是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数

![image-20211102210341125](https://i.loli.net/2021/11/02/W2lpvHhcNOg56Ru.png)

### 最佳实践

在大多数实际情况中，快速排序是最佳选择，但是当为实际应用开发应用程序时，你会发现Java的

`Arrays.sort()`实现已经基本够用了，因为它使用的三向快速排序和归并排序都是经典

> 对于 java.util.Arrays.sort(),根据不同的参数类型，实际上每种原始数据类型都有一个不同的排序方法，感兴趣可以自行阅读源码

### 冒泡排序

> 逆序数等于一个序列要变成**升序排列**所需要的**相邻元素**交换的**最小**次数（仅适用于冒泡排序）

冒泡排序是一种简单的排序算法,不管原始数组是否有序，**时间复杂度都是O（n^2）**，

对于拥有N个字母的字符串，最多需要交换N*(N-1)/2次

**算法描述**

比较相邻的元素。如果第一个比第二个大，就交换它们两个，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数,因此要搞懂需要比较的次数便成为了一个难点

并且原始的冒泡排序并不高效，可以自行搜索冒泡排序的优化，但总的来说，除非数据量很小，否则一般不推荐冒泡排序

**动图演示**

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif)

**Java代码**

```java
//冒泡排序
    public static void bubbleSort(int[] arr) {
        long startTime = System.currentTimeMillis();   //获取开始时间
        for (int i = 0; i < arr.length - 1; i++) {
            //i可以理解为最后已经排好序的元素的个数
            for (int j = 0; j < arr.length - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    //通过位运算交换两数字
                    arr[j] ^= arr[j + 1];
                    arr[j + 1] ^= arr[j];
                    arr[j] ^= arr[j + 1];
                }
            }
        }
        long endTime = System.currentTimeMillis(); //获取结束时间
        System.out.println("程序运行时间： " + (endTime - startTime) + "ms");
    }
```

### 选择排序

**算法描述**

选择排序(Selection-sort)是一种<u>简单直观</u>的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕

**动图演示**

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif)

**Java代码**

```java
public static void selectionSort(int[] arr) {
        long startTime = System.currentTimeMillis();   //获取开始时间
        int minIndex;
        for (int i = 0; i < arr.length - 1; i++) {
            minIndex = i;
            for (int j = i + 1; j < arr.length - 1; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            arr[i]^=arr[minIndex];
            arr[minIndex]^=arr[i];
            arr[i]^=arr[minIndex];
        }
        long endTime = System.currentTimeMillis(); //获取结束时间
        System.out.println("程序运行时间： " + (endTime - startTime) + "ms");
    }
```

### 快速排序！

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif)

> 关键词：分治、递归、双向扫描

**算法描述**

基本思想就是选取一个基准，一趟排序确定两个区间，一个区间全部比基准值小，另一个区间全部比基准值大，接着再选取一个基准值来进行排序，以此类推，最后得到一个有序的数列。

> 具体算法描述如下

快速排序分为大体可以分为两步：

1. 切分操作

   从数列中挑出一个元素，称为 “基准”（pivot），重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作

2. 递归排序

   **递归调用**快速排序的函数对两个区间再进行以上操作，直到调用的区间为空或是只有一个数,《算法4》中指出，用归纳法可以证明递归能够正确的将数组进行排序

```java
	public static void quickSort(int[] arr,int low, int high){
		if(hi<=lo)   return;
    	int piovt = partition(arr,low,high);//分区操作
        quickSort(aee,low,pivot-1);
        quickSort(arr,pivot+1,hi)
    }
```

> 切分操作指南--双指针双向扫描
>
> 定义一个基准pivot(这个基准最好是处于这个待排序数组的中间值附近)，在快排中，[选择一个好的中轴选择策略会使算法的效率显著提高](https://blog.csdn.net/ljianhui/article/details/16797431)，我们定义arr[0]为pivot,然后
>
> 1. 先从最右位置往左开始找直到找到一个小于基准数的值，记录下该值的位置（记作 **i**）
> 2. 再从最左位置往右找直到找到一个大于基准数的值，记录下该值的位置（记作 **j**）
> 3. 如果位置i<j，则交换i和j两个位置上的值，然后继续从**(j-1)的位置往前**和**(i+1)的位置往后**重复上面比对基准数然后交换的步骤
> 4. 如果执行到i==j，表示本次比对已经结束，将最后i的位置的值与基准数做交换，此时基准数就找到了临界点的位置k，位置k两边的数组都比当前位置k上的基准值或都更小或都更大
> 5. 上一次的基准值7已经把数组分为了两半，**基准值算是已归位（找到排序后的位置）**

快排代码

```java
public static int[] sort(int[] ins ,int start,int end) {
        if (start >= end) {
            return ins;//这个返回值并没有影响，因为这个返回值没有使用到。
        }
        int pivot = ins[start];//定义基准
        int low = start;
        int hight = end;

        while (low < hight) {
            while (low < hight && ins[hight] >= pivot) {//从右边开始找一个小于mid的数
                hight -= 1;
            }
            ins[low] = ins[hight];//找到以后与基准交换

            while (low < hight && ins[low] < pivot) {//从左开始找一个大于mid的数
                low += 1;
            }
            ins[hight] = ins[low];//交换
        }
        ins[low] = pivot;//当low>=height时，停止查找，将基准归位

        sort(ins, start, low - 1);
        sort(ins, low + 1, end);
        return ins;
    }
```

### 插入排序

**算法描述**

插入排序（Insertion Sorting）的基本思想是: 把 n 个待排序的元素看成为一个有序表和一个无序表，开始时 有序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，寻找合适的插入位置

**动图演示**

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif)

**Java代码**

```java
	public static void insertSort(int[] arr) {
        long startTime = System.currentTimeMillis();   //获取开始时间
        //假定第i个元素有序,i=1，这个for循环说明了n个数的数组需要遍历n-1次
        for (int i = 1; i < arr.length; i++) {
            int preIndex = i - 1; //定义
            int current = arr[i]; //定义待插入的数
            //遍历有序列表找到合适的插入位置
            while (preIndex >= 0 && arr[preIndex] > current) {
                arr[preIndex + 1] = arr[preIndex];
                preIndex--;
            }
            arr[preIndex + 1] = current;
        }
        long endTime = System.currentTimeMillis(); //获取结束时间
        System.out.println("程序运行时间： " + (endTime - startTime) + "ms");
    }
```

### 希尔排序

首先思考一下插入排序存在的问题==》当需要插入的数是较小的数时， 后移的次数明显增多，对 效率有影响.

希尔排序也是一种插入排序，1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序经过改进之后的一个 更高效的版本，也称为**缩小增量排序**

**算法描述**

​	希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止

​	简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。

　　而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。

**动图演示**

![](https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190420100142756-421005088.gif)

**Java代码**

```java
	public static void shellSort(int[] arr) {
        long startTime = System.currentTimeMillis();   //获取开始时间
        //控制增量序列,增量序列为1的时候为最后一趟
        for (int i = arr.length / 2; i > 0; i /= 2) {
            //根据增量序列，找到每组比较序列的最后一个数的位置
            for (int j = i; j < arr.length; j++) {
                //根据该比较序列的最后一个数的位置，依次向前执行插入排序
                for (int k = j - i; k >= 0; k -= i) {
                    if (arr[k] > arr[k + i]) {
                        arr[k] ^= arr[k + i];
                        arr[k + i] ^= arr[k];
                        arr[k] ^= arr[k + i];
                    }
                }
            }
        }
        long endTime = System.currentTimeMillis(); //获取结束时间
        System.out.println("希尔排序运行时间： " + (endTime - startTime) + "ms");
    }
```

**算法分析**

希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的

### 归并排序

**算法描述**

归并排序就是递归得将原始数组递归对半分隔，直到不能再分（只剩下一个元素）后，开始从最小的数组向上归并排序

1. 向上归并排序的时候，需要一个**暂存数组**用来排序，

2. 将待合并的两个数组，从第一位开始比较，小的放到暂存数组，指针向后移，

3. 直到一个数组空，这时，不用判断哪个数组空了，直接将两个数组剩下的元素追加到暂存数组里，

4. 再将暂存数组排序后的元素放到原数组里，两个数组合成一个，这一趟结束

**动图演示**

![](https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190326201207440-689679432.gif)

![](https://s3.bmp.ovh/imgs/2021/11/cc5199afca786911.png)



**Java代码**

```java

```



### 基数排序



### 堆排序



## 查找算法

> 序

​	首先我们要弄清楚查找表、记录、关键字、主关键字、静态查找表、动态查找表等这些概念。
然后，对于**顺序查找**来说，尽管很土（简单)，但它却是后面很多查找的基础。
​	有序查找，着重了解**二分查找**的思想，它在性能上比原来的顺序查找有了质的飞跃，时间复杂度由`O(n)`变成了`O(logN)`。之后我们又讲解了另外两种优秀的有序查找:**插值查找**和斐波那契查找,三者各有优缺点,望大家要仔细体会。
​	二叉排序树是动态查找最重要的数据结构，它可以在兼顾查找性能的基础上，让插入和删除也变得效率较高。不过为了达到最优的状态，二叉排序树最好是构造成平衡的二叉树才最佳。因此我们就需要再学习关于平衡二叉树(AVL 树）的数据结构，了解AVL树是如何处理平衡性的问题。这部分是本章重点，需要认真学习掌握。
​	B树这种数据结构是针对内存与外存之间的存取而专门设计的。由于内外存的查找性能更多取决于读取的次数，因此在设计中要考虑B树的平衡和层次。我们讲解时是先通过最最简单的B树(2-3树)来理解如何构建、插入、删除元素的操作，再通过2-3-4树的深化,最终来理解B树的原理。之后,我们还介绍了B+树的设计思想。
​	散列表是一种非常高效的查找数据结构，在原理上也与前面的查找不尽相同，它回避了关键字之间反复比较的烦琐，而是直接一步到位查找结果。当然，这也就带来了记录之间没有任何关联的弊端。应该说，散列表对于那种查找性能要求高，记录之间关系无要求的数据有非常好的适用性。在学习中要注意的是散列函数的选择和处理冲突的方法。





### 二分查找

> 二分查找是对于**有序列表**的查找技术，如果是无序的则要先进行排序操作，相对于顺序查找(就是for循环一个个遍历)，时间复杂度有了质的提升，由O(n)变为O(logN)

> **折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要**频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用，对于动态查找表，可以考虑二叉排序树的查找技术
>
> ​			                                     ——《大话数据结构》

> 另外比较优秀的有序查找算法为 **插值查找**、**斐波那契查找**，三者各有优缺点，可以自行了解，仔细体会

**算法思想**

二分查找的思想非常简单，有点类似分治的思想。二分查找针对的是一个有序的数据集合，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0

![image-20211104162536005](https://i.loli.net/2021/11/04/w5T8OfHigALlEvy.png)

**Java代码**

递归实现

```java
	/**
     * @param arr 被排序数组
     * @param left 查找起始位置
     * @param right 查找结束位置
     * @param findVal 需要查找的值
     */

    public static void binarySearch(int[] arr, int left, int right, int findVal) {
        int mid = (left + right) / 2;
        if (arr[mid] < findVal) //向右递归
            binarySearch(arr,mid+1,arr.length-1,findVal);
        if (arr[mid] > findVal) //向左递归
            binarySearch(arr,left,mid-1,findVal);       
        if (arr[mid] == findVal){//找到索引值,扫描其左右侧
            List<Integer> list = new ArrayList<Integer>();
            //扫描左侧
            for (int i = left; i < mid; i++) {
                if (arr[i]==findVal)
                    list.add(i);
            }
            //扫描右侧
            for (int i = mid; i < right; i++) {
                if (arr[i]==findVal)
                    list.add(i);
            }
            System.out.println(findVal + " 二分查找的索引值为:" + list);
        }
    }
```

非递归

```java
		public static void binarySearch2(int[] arr, int left, int right, int findVal){
        while(left <= right) { //说明继续查找
            int mid = (left + right) / 2;
            if(arr[mid] == findVal) {
                System.out.println("二分非递归索引位置："+mid);
                break;
            } else if ( arr[mid] > findVal) {
                right = mid - 1;//需要向左边查找
            } else {
                left = mid + 1; //需要向右边查找
            }
        }

    }
```



### 插值查找

​	在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？

　　打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。

​	经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：

　　`mid=(low+high)/2, 即mid=low+1/2*(high-low)`;

　　通过类比，我们可以将查找的点改进为如下：

　　`mid=low+(value-a[low])/(a[high]-a[low])*(high-low)`

也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。

**算法思想**

基于二分查找算法，将查找点的选择改进为自适应选择,插值查找的核心是插的计算公式，可以提高查找效率。当然，差值查找也属于有序查找

> 注：**对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。**

**Java代码**

```java
public static int insertValueSearch(int[] arr, int left, int right, int findVal) {
        //注意：findVal < arr[0] 和 findVal > arr[arr.length - 1] 必须需要
        //否则我们得到的 mid 可能越界
        if (left > right || findVal < arr[0] || findVal > arr[arr.length - 1]) {
            return -1;
        }
        // 求出 mid, 自适应
        int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);
        int midVal = arr[mid];
        if (findVal > midVal) { // 说明应该向右边递归
            return insertValueSearch(arr, mid + 1, right, findVal);
        } else if (findVal < midVal) { // 说明向左递归查找
            return insertValueSearch(arr, left, mid - 1, findVal);
        } else {
            return mid;
        }
    }
```



> 以上两种比较高效的查找方法都是基于有序的基础之上的,但事实上，很多数据集可能增长非常快，例如，某些微博网站或大型论坛的帖子和回复总数每天都是成百万上千万条，如图8-5-1所示，或者一些服务器的日志信息记录也可能是海量数据，要保证记录全部是按照当中的某个关键字有序，其时间代价是非常高昂的，所以这种数据通常都是按先后顺序存储。
>
> 那么对于这样的查找表，我们如何能够快速查找到需要的数据呢?办法就是---**索引**
>
> 对于线性索引查找（本文并未涉及）,可以自行了解**稠密索引**、**分块索引**和**倒排索引**。索引技术被广泛的用于文件检索、数据库和搜索引擎等技术领域，是进一步学习这些技术的基础。

### 散列表查找（哈希表）概述

通过之前的查找我们发现，为了查找到结果，“比较”是不可避免的，但这是否真的有必要?

能否直接通过关键字key得到要查找的记录内存存储位置呢



==》这就引出了一种存储结构——散列表



![image-20211104194840702](https://i.loli.net/2021/11/04/1IyxprqNhKOElzu.png)



> 散列函数的设计



## 递归与分治

### 定义与适用情况

> 递归定义

+ 程序调用自身的编程技巧称为递归（ recursion）
+ 递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量

> 什么时候用递归

递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解

> 分治定义

**核心思想：减小问题的规模，抽象步骤并一般化**

在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)



### 如何设计算法

> 如何设计一个递归

1. 找重复子问题： n*(n-1)的阶乘,求n-1的阶乘是原问题的重复，也可以理解为规模更小的子问题
   1. 找到一种划分方法
   2. 找到递推公式或者等价转换
2. 找变化量：找到变化的参数，传入形参，通过这个参数来结束递归
3. 找边界：递归结束的条件

> **依据分治法设计程序时的思维过程**

实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序

1、一定是先找到最小问题规模时的求解方法

2、然后考虑随着问题规模增大时的求解方法

3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可

### 常见的递归代码

这样说可能会有点空洞，我们来看下面几个例子

> 简单的递归--切蛋糕思维

+ 递归求一个数的阶乘

  ```javascript
  	static int factorial(int num){
          if (num==1)
              return 1;
          return num*factorial(num-1);
      }
  ```

+ 递归求最大公约数————GCD算法

  ```java
  	static int factorial(int num){
          if (num==1)
            return 1;
          return num*factorial(num-1);
      }
  ```

+ 对arr的所有元素求和

  ```java
   	static int sum(int[] arr,int begin){
          if(begin = arr.length()-1)//当begin是最后一个元素
              return arr[begin];//返回begin即可
          return arr[begin] + sum(arr,begin+1);
      }
  ```

+ 翻转字符串

  ```java
   	//翻转字符串
      static String reverse(String str,int endIndex){
          return str.charAt(endIndex)+reverse(str,endIndex-1);
      }
  ```

> 难一点的递归--等价转换，找递推公式

+ 斐波那契数列

```java
	static int fib(int num) {//这个数字是指递归的次数，和斐波那契数本身没有关系
        if (num == 1 || num == 2)
            return 1;
        return fib(num - 1) + fib(num - 2);
    }
```

+ 最大公因数

```java
	static int gcd(int x, int y) {
        if (y == 0)
            return x;
        return gcd(y, x % y);
    }
```



> 递归需要注意的问题

1. 尽量不使用递归
2. 当程序指定到一个方法时，就会开辟一个独立的栈，因此要会判断栈是否会溢出
3. 可以把递归理解为循环嵌套

### 汉诺塔问题

**汉诺塔是递归 + 分治思想的体现**

先来看题目

> 汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间**一次只能移动一个圆盘**。
> 假如每秒钟一次，共需多长时间呢？移完这些圆盘需要 5845.54 亿年以上，太阳系的预期寿命据说也就是数百亿年。真的过了 5845.54 亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。

这是一个简单的汉诺塔模型（只有三个圆盘）

**问题描述**：

给定一个n，说明A柱有n个数字的圆盘，按找汉诺塔的规则，将圆盘移动到B柱,解法如下

<img src="https://www.biancheng.net/uploads/allimg/201202/2-2012021AUKS.gif" style="zoom:150%;" />



> 分治思想的体现
>
> 而对于复杂的汉诺塔模型，我们可以把做看作两部分
>
> 1.最下边的一个盘
>
> 2.上面的所有盘（又可以看作两部分来处理）
>
> 要解决n个，先解决n-1个，**可以分治为n=1和n>=2的最简单情况并加以解决**

> 递归思想的体现
>
> 将N个圆盘从A柱移动到B柱
>
> ​	等价于
>
> ​	1、将N-1个圆盘移动到C柱，B柱为辅助柱
>
> ​	2、将第N个圆盘移动到B柱
>
> ​	3、将N-1个圆盘移动到B柱，A柱为辅助柱
>
> 
>
> 递归变化量：每个子问题移动的柱子在减少
>
> 递归结束条件：当圆盘数量=1时，将这个圆盘放在最上方即可

**Java代码**

```java
/**
     * 打印将N个盘子移动到目标盘的路径
     *
     * @param num  圆盘个数
     * @param from 初始柱子
     * @param help 辅助柱子
     * @param to   目标柱子
     */
static void hanoiTower(int num, char from, char to, char help) {
        if (num == 1) {
            System.out.println("第1个盘从" + from + "->" + to);
        } else {//n >= 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘
            hanoiTower(num - 1, from, help, to);
            //最下面的到目标柱子
            System.out.println("第" + num + "个盘从 " + from + "->" + to);
            //让N-1回到初始柱子
            hanoiTower(num - 1, help, to, from);
        }
    }
```

### 小结

使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。这里我列举了几道算法题目，这几道算法题目都可以用递归轻松写出来：

- 递归实现 sum
- 二叉树的遍历
- 走楼梯问题
- 汉诺塔问题
- 杨辉三角

递归中**如果**存在重复计算（我们称重叠子问题，下文会讲到），那就是使用记忆化递归（或动态规划）解题的强有力信号之一。可以看出动态规划的核心就是使用记忆化的手段消除重复子问题的计算，如果这种重复子问题的规模是指数或者更高规模，那么记忆化递归（或动态规划）带来的收益会非常大。

为了消除这种重复计算，我们可使用查表的方式。即一边递归一边使用“记录表”（比如哈希表或者数组）记录我们已经计算过的情况，当下次再次碰到的时候，如果之前已经计算了，那么直接返回即可，这样就避免了重复计算。下文要讲的**动态规划中 DP 数组其实和这里“记录表”的作用是一样的**。

如果你刚开始接触递归， 建议大家先去练习一下递归再往后看。一个简单练习递归的方式是将你写的迭代全部改成递归形式。比如你写了一个程序，功能是“将一个字符串逆序输出”，那么使用迭代将其写出来会非常容易，那么你是否可以使用递归写出来呢？通过这样的练习，可以让你逐步适应使用递归来写程序。

当你已经适应了递归的时候，那就让我们继续学习动态规划吧！

## 动态规划

动态规划相信大家都知道，动态规划算法也是新手在刚接触算法设计时很苦恼的问题，有时候觉得难以理解，但是真正理解之后，就会觉得动态规划其实并没有想象中那么难。网上也有很多关于讲解动态规划的文章，大多都是叙述概念，讲解原理，让人觉得晦涩难懂，即使一时间看懂了，发现当自己做题的时候又会觉得无所适从。我觉得，理解算法最重要的还是在于练习，只有通过自己练习，才可以更快地提升。话不多说，接下来，下面我就通过一个例子来一步一步讲解动态规划是怎样使用的，只有知道怎样使用，才能更好地理解，而不是一味地对概念和原理进行反复琢磨

### 算法描述

> 定义

**动态规划**（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题动态规划和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

这样的述太过官方，那到底该如何理解动态规划呢？

+ 阶段之间可以进行转移，这叫做动态
+ 达到一个可行解(目标阶段) 需要不断地转移，那如何转移才能达到最优解？这叫规划

动态规划，无非就是利用**历史记录**，来避免我们的重复计算。而这些**历史记录**，我们得需要一些**变量**来保存，一般是用**一维数组**或者**二维数组**来保存。下面我们先来讲下做动态规划题很重要的三要素和三个步骤

> 三要素

动态规划问题的进阶一般形式就是求最值，也常被用来优化递归算法。比如说让你求`最长递增子序列`呀，`最小编辑距离`呀等等

既然是要求最值，核心问题是什么呢？**求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。

这么一说，好像动态规划很简单？

但是，动态规划的穷举有点特别，因为这类问题**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来记录数据，优化穷举过程，避免不必要的计算。

而且，动态规划问题一定会**具备「最优子结构」**，才能通过子问题的最值得到原问题的最值。

另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的**「状态转移方程」**才能正确地穷举。

**以上提到的:tangerine:`重叠子问题`、`最优子结构`、`状态转移方程`就是动态规划三要素**

理解这些名词最好的方法就是在题目中去感受它们，刷题越多，对动态规划也就有了一定的感觉

### 入门动态规划

> 三个步骤

1. **第一步骤**：定义**数组元素的含义**，上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？
2. **第二步骤**：找出**数组元素之间的关系式**，我觉得动态规划，还是有一点类似于我们高中学习时的**归纳法**的，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2]…..dp[1]，来推出 dp[n] 的，也就是可以利用**历史数据**来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。而这一步，也是最难的一步，后面我会讲几种类型的题来说。
3. **第三步骤**：找出**初始值**。学过**数学归纳法**的都知道，虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值，而这，就是**所谓的初始值**（Base case）

由了**初始值**，并且有了**数组元素之间的关系式**，那么我们就可以得到 dp[n] 的值了，而 dp[n] 的含义是由你来定义的，你想**求什么，就定义它是什么**，这样，这道题也就解出来了。



之后我们进入刷题环节



从青蛙跳楼梯的部分开始入门吧

> 问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法

首先如果只有1个台阶，那青蛙只有一种跳法；如果有两个台阶，青蛙有两种跳法：一个台阶一个台阶跳；一次跳两个台阶；如果有n（n > 2）个台阶，假设用函数f（n）表示总共跳的方法数，这时青蛙在第一次有两种选择：选择跳一个台阶，则剩下n-1个台阶故剩下的台阶有f（n-1）种跳法；选择跳两个台阶，则剩下n-2个台阶故剩下的台阶有f（n-2）种跳法。

从后往前递推，完成n级台阶的最后一次动作可能是跳1级，可能是跳2级，故f（n）= f（n-1） + f（n-2）；n=1时f（n） = 1；n = 2时f（n）= 2；于是可以看到这个题目是明显的递归

```java
 	//基于递归实现
public long jumpStep(int n){
	if (n == 0 || n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 2] + dp[i - 1];
        }
        return dp[n];  
}
```

然后我们用动态规划来理解这道题



 **(1)、定义数组元素的含义**

按我上面的步骤说的，首先我们来定义 dp[i] 的含义，我们的问题是要求青蛙跳上 n 级的台阶总共由多少种跳法，那我们就定义 dp[i] 的含义为：**跳上一个 i 级的台阶总共有 dp[i] 种跳法**。这样，如果我们能够算出 dp[n]，不就是我们要求的答案吗？所以第一步定义完成

**（2）、找出数组元素间的关系式**

我们的目的是要求 dp[n]，动态规划的题，如你们经常听说的那样，就是把一个**规模**比较大的问题分成几个**规模**比较小的问题，然后由小的问题推导出大的问题。也就是说，dp[n] 的规模为 n，比它规模小的是 n-1, n-2, n-3…. 也就是说，dp[n] 一定会和 dp[n-1], dp[n-2]….存在某种关系的。我们要找出他们的关系。

那么问题来了，怎么找？

这个怎么找，**是最核心最难的一个**，我们必须回到问题本身来了，来寻找他们的关系式，dp[n] 究竟会等于什么呢？

```
设跳上 n 级台阶有 dp(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶

当为 1 级台阶： 剩 n−1 个台阶，此情况共有 f(n−1) 种跳法；
当为 2 级台阶： 剩 n−2 个台阶，此情况共有 f(n−2) 种跳法。
```

由于我们是要算所有可能的跳法的，所以有 dp[n] = dp[n-1] + dp[n-2]



**（3）、找出初始条件**

当 n = 1 时，dp[1] = dp[0] + dp[-1]，而我们是数组是不允许下标为负数的，所以对于 dp[1]，我们必须要**直接给出它的数值**，相当于初始值，显然，dp[1] = 1。一样，dp[0] = 0.（因为 0 个台阶，那肯定是 0 种跳法了）。于是得出初始值：

dp[0] = 0



三个步骤都做出来了，那么我们就来写代码吧

```java
int numWays( int n ){
    	if (n == 0 || n == 1) return 1;
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = (dp[i - 2] + dp[i - 1]);
        }
        return dp[n];
}
```

到这里，我们写出了第一个动态规划代码。但是我们为什么要这样做呢？那我们来看一下动态规划是怎样优化递归函数的叭，这里会涉及到**重叠子问题**这个概念



对了，动态规划也是可以优化的哦，以后有机会我会记录这方面的内容



####  斐波那契数

它并不是动态规划问题，但是可以帮助理解 重叠子问题 这个概念

> 题目：求斐波那契数
>
> **斐波那契数列**指的是这样一个数列：1，1，2，3，5，8，13，21，34，55，89...
>
> 这个数列从第3项开始，每一项都等于前两项之和

重叠子问题：用来求解原问题的递归算法反复地解同样的子问题，而不是总是在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的

```java
 	public static int fibonacci(int n){
        if (n== 1||n==2)
            return 1;
        return fibonacci(n-1)+fibonacci(n-2);
    }
```

画出递归树，可以看到如果要求 fibonacci(20), 那么`fabnacci(18)`会涉及到重复计算，存在大量重复计算，比如`fabnacci(18)`被计算了两次，而且你可以看到，以`fabnacci(18)`为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止`fabnacci(18)`这一个节点被重复计算，所以这个算法及其低效。

![image-20220316140536074](https://img-blog.csdnimg.cn/img_convert/c174fee9ca43a87b1d3017119c7fcfc7.png)



明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了

> 演进一：**带备忘录的递归解法**

```java
	//带备忘录的递归 
	//时间复杂度O(n)
    public static int fib(int n){
        int[] memory = new int[n+1];
        return fib(n,memory);
    }
    public static int fib(int n,int[] memoary) {
        //base case
        if (n == 1 || n == 2) return 1;
        if (memoary[n]!=0) return memoary[n];
        memoary[n] = fib(n-1,memoary)+fib(n-2,memoary); 	
        return memoary[n];
    }
```

本算法不存在冗余计算，子问题就是`fib(1)`,`fib(2)`,`fib(3)`…`fib(20)`，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。

至此，带备忘录的递归解法的效率已经和迭代的动态规划一样了。实际上，这种解法和迭代的动态规划思想已经差不多，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。

> 优化二：**dp 数组的迭代解法**--引出状态转移方程

有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算

```java
	//时间复杂度O(n)
    public static int fib2(int n) {
        int[] dp = new int[n + 1];//DP table
        dp[1] = dp[2] = 1;//base case
        for (int i = 3; i <= n; i++)
            dp[i] = dp[i - 1] + dp[i - 2];//状态转移方程
        return dp[n];
```

在这里引出`「状态转移方程」`这个名词，实际上就是描述问题结构的数学形式

我把它理解为一个分段函数，例如对斐波那契数这个例子

![image-20220316151733235](https://img-blog.csdnimg.cn/img_convert/774a8e397eb76f89231d84e261c79fdd.png)



希望读者可以通过这个例子对重叠子问题和状态转移方程有一个基本的理解，但是动态规划的另一个重要特性「最优子结构」，并没有在这个例子中涉及到，因为斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在演示算法设计螺旋上升的过程。



我们来看下一个问题

#### 背包问题

+ 01背包：每种物品不可重复
+ 完全背包：每种物品可以无限使用

> **0—1背包**
>
> 给你一个可装载重量为`W`的背包和`N`个物品，每个物品有重量和价值两个属性。其中第`i`个物品的重量为`wt[i]`，价值为`val[i]`，现在让你用这个背包装物品，最多能装的价值是多少

**这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。**这也许就是 0-1 背包这个名词的来历。



我们分别理解状态和转移，然后按照下面的步骤来做题

1. 第一步要明确两点，「状态」和「选择」

   背包的容量/所有物品

2. 第二步要明确`dp`数组的定义--两个状态，考虑二维dp

   `dp[i][w]`的定义：对于前`i`个物品，当前背包的容量为`w`，这种情况下最大价值是`dp[i][w]`

   **根据这个定义，我们想求的最终答案就是**`dp[N][W]`

   **base case 就是`dp[0][..] = dp[..][0] = 0`**，因为没有物品或者背包没有空间的时候，最大价值就是 0。

3. 第三步，根据「选择」，思考状态转移的逻辑

   

然后给出一个动态规划思考的模板思路

```java
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
```

按照这个思路理一下框架

```java
int dp[N+1][W+1]
dp[0][..] = 0
dp[..][0] = 0

for i in [1..N]:
    for w in [1..W]:
        dp[i][w] = max(
            把物品 i 装进背包,
            不把物品 i 装进背包
        )
return dp[N][W]
```

Java代码描述

```java
/**
     * @param W 背包容量
     * @param N 物品数量
     * @param wt Wt[i]代表第i个物品的重量
     * @param val val[i]代表第i个物品的价值
     * @return
     */
    public static int knapsack(int W, int N, int[] wt,int[] val) {
        //base case 已初始化
        //dp[i][w]表示对于前i个物品，当前背包的容量为w，这种情况下可以装的最大价值是dp[i][w]
        int[][] dp = new int[N+1][W+1];
        for (int i = 1; i <= N; i++) {
            for (int w = 1; w <= W; w++) {
                if (w - wt[i-1] < 0) {
                    // 当前背包容量装不下，只能选择不装入背包
                    dp[i][w] = dp[i - 1][w];
                } else {
                    // 装入或者不装入背包，择优
                    dp[i][w] = Math.max(dp[i - 1][w - wt[i-1]] + val[i-1],
                            dp[i - 1][w]);
                }
            }
        }
        return dp[N][W];
    }
```

> 完全背包
>
> 有一个背包，最大容量为`amount`，有一系列物品`coins`，每个物品的重量为`coins[i]`，**每个物品的数量无限**。请问有多少种方法，能够把背包恰好装满

无非就是状态转移方程有一点变化而已

以力扣518题为例

https://leetcode-cn.com/problems/coin-change-2/

```java
int change(int amount, int[] coins) {
    int n = coins.length;
    int[][] dp = amount int[n + 1][amount + 1];
    // base case
    for (int i = 0; i <= n; i++) 
        dp[i][0] = 1;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= amount; j++)
            if (j - coins[i-1] >= 0)
                dp[i][j] = dp[i - 1][j] 
                         + dp[i][j - coins[i-1]];
            else 
                dp[i][j] = dp[i - 1][j];
    }
    return dp[n][amount];
}
```

来看下一个问题

#### 凑零钱问题

力扣[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

> 题目：给你`k`种面值的硬币，面值分别为`c1, c2 ... ck`，每种硬币的数量无限，再给一个总金额`amount`，问你**最少**需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：
>
> ```java
> // coins 中是可选硬币面值，amount 是目标金额
> int coinChange(int[] coins, int amount);
> ```

通过这道题理解最优子结构这个概念为什么说它符合最优子结构呢？比如你想求`amount = 11`时的最少硬币数（原问题），如果你知道凑出`amount = 10`的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案



既然确定了这是一个动规问题

> **明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。**

我们回到凑零钱问题

1. 找到状态： 目标金额amount

2. 确定dp函数的定义：函数 dp(n)表示，当前的目标金额是`n`，至少需要`dp(n)`个硬币凑出该金额

3. 确定「选择」并择优： 也就是对于每个状态，可以做出什么选择改变当前状态。

   具体到这个问题，无论当的目标金额是多少，选择就是从面额列表`coins`中选择一个硬币，然后目标金额就会减少、

自底向上**使用 dp table 来消除重叠子问题**，dp[i]表示，当目标金额为i时至少需要i枚硬币

```java
   public int coinChange(int[] coins, int amount) {
        int max = amount + 1;
       	//定义dp数组大小为amount+1,初始值也为amount+1,
       //为什么dp数组初始化为amount + 1呢，因为凑成amount金额的硬币数最多只可能等于amount（全用 1 元面值的硬币），所以初始化为amount + 1就相当于初始化为正无穷，便于后续取最小值
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, max);
        dp[0] = 0;//base case
        for (int i = 1; i <= amount; i++) {//amount为金额
            for (int j = 0; j < coins.length; j++) {             
                if (coins[j] <= i) {//如果可以用硬币表示
                   	//找到上一个数+x个硬币数量的最小值
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
       	//所需要金币数量大于金额，说明无解，返回-1
        return dp[amount] > amount ? -1 : dp[amount];
    }
```

### 进阶动态规划

> 求最大连续和问题

#### 最大连续和

[剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

**问题描述**

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

示例1:

输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

> 思路：可以用前缀和来做，这里我们说动态规划
>
> 难点在于对状态转移方程的定义：
>
> 用 dp[i] 代表以第 *i* 个数结尾的「连续子数组的最大和」

> 动态规划--- 最佳实践 时间复杂度 O(n)

设滚动变量 dp ，代表以元素 nums[i] 为结尾的连续子数组最大和

```java
class Solution {
   public int maxSubArray(int[] nums) {
        int pre = 0;
        int dp = nums[0];//滚动变量
        for (int x : nums) {
            pre = Math.max(x + pre, x);
            dp = Math.max(dp, pre);
        }
        return dp;
    }
}
```

#### 最长递增子序列

> 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
>
> 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
>
>
> 示例 1：
>
> 输入：nums = [10,9,2,5,3,7,101,18]
> 输出：4
> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

> 思路：
>
> 利用Hash表，key存储num[i],value存储num[i]对应的右边界
>
> 初始化哈希表，key和value都等于num[i]
>
> 遍历Hash表，动态更新每个数的最右边界，动态更新最大最右边界

```java
 //key存值，value保存右边界
        public int longestConsecutive(int[] nums) {
            HashMap<Integer, Integer> map = new HashMap<>();
            int ans = 0;
            for (int num : nums)
                map.put(num, num);//初始化
            //更新边界
            for (int num : nums) {
                if (!map.containsKey(num - 1)) {//如果不包含上一个值，那么开始更新这个值
                    int right = map.get(num);
                    while (map.containsKey(right + 1)) {
                        right = map.get(right + 1);
                    }
                    //更新边界
                    map.put(num, right);
                    ans = Math.max(ans, right - num + 1);
                }
            }
            return ans;
        }
    }
```

#### 最长公共子序列

> 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。
>
> 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
>
> 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
> 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。
>
> 示例 1：
>
> 输入：text1 = "abcde", text2 = "ace" 
> 输出：3  
> 解释：最长公共子序列是 "ace" ，它的长度为 3 

```java
// 定义：将 s1[i..] 和 s2[j..] 删除成相同字符串，
// 最小的 ASCII 码之和为 dp(s1, i, s2, j)。
int dp(String s1, int i, String s2, int j) {
    int res = 0;
    // base case
    if (i == s1.length()) {
        // 如果 s1 到头了，那么 s2 剩下的都得删除
        for (; j < s2.length(); j++)
            res += s2.charAt(j);
        return res;
    }
    if (j == s2.length()) {
        // 如果 s2 到头了，那么 s1 剩下的都得删除
        for (; i < s1.length(); i++)
            res += s1.charAt(i);
        return res;
    }

    if (memo[i][j] != -1) {
        return memo[i][j];
    }

    if (s1.charAt(i) == s2.charAt(j)) {
        // s1[i] 和 s2[j] 都是在 lcs 中的，不用删除
        memo[i][j] = dp(s1, i + 1, s2, j + 1);
    } else {
        // s1[i] 和 s2[j] 至少有一个不在 lcs 中，删一个
        memo[i][j] = Math.min(
            s1.charAt(i) + dp(s1, i + 1, s2, j),
            s2.charAt(j) + dp(s1, i, s2, j + 1)
        );
    }
    return memo[i][j];
}
```



### 浅谈分治与动态规划

分治和动态规划有相似之处也有不同，我们来看如下两个定义。

> 最优子结构：如果问题的一个最优解中包含了子问题的最优解，则该问题具有最优子机构。

> 重叠子问题：用来求解原问题的递归算法反复地解同样的子问题，而不是总是在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。

> 动态规划要求其子问题既要独立又要重叠，这看上去似乎有些奇怪。虽然这两点要求听起来可能矛盾的，但它们描述了两种不同的概念，而不是同一个问题的两个方面。如果同一个问题的两个子问题不共享资源，则它们就是独立的。对两个子问题俩说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。
>
> ​													————————算法导论

当子问题相互独立时，能且只能使用分治。

存在重叠子问题时，动态规划是更好的算法。 

综上，

分治法 ——》 各子问题独立

动态规划 ——》 各子问题重叠



## 贪心算法

:factory:**如果你没有模拟所有可能，而直接走了一条最优解，那就是贪心算法了**







## 字符串

### KMP算法





## 图论

主要涉及到图的遍历算法，学习算法前应该首先了解图的存储形式

### 图的存储结构

图的存储结构除了要存储图中的各个顶点本身的信息之外，还要存储顶点与顶点之间的关系，因此，图的结构也比较复杂。常用的图的存储结构有邻接矩阵和邻接表等

> 二维数组表示---邻接矩阵

图的**邻接矩阵**（Adjacency Matrix）存储方式是**用两个数组来表示图**。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息

+ 无向图

  无向图的边数组是一个对称矩阵

![image-20220302152448487](https://s2.loli.net/2022/03/02/egpWmAfdDGC62Mk.png)

+ 有向图

![image-20220302152513755](https://s2.loli.net/2022/03/02/8jN6AF2VOHQPMtf.png)

由于存在n个顶点的图需要n*n个数组元素进行存储，**当图为稀疏图时，使用邻接矩阵存储方法将会出现大量0元素，这会造成极大的空间浪费**。这时，可以考虑使用邻接表表示法来存储图中的数据

> 链表表示---邻接表

首先，回忆我们在线性表时谈到，顺序存储结构就存在预先分配内存可能造成存储空间浪费的问题，于是引出了链式存储的结构。同样的，我们也可以考虑对边或弧使用链式存储的方式来避免空间浪费的问题。       

邻接表由**表头节点**和**表节点**两部分组成，图中每个顶点均对应一个存储在数组中的表头节点。如果这个表头节点所对应的顶点存在邻接节点，则把邻接节点依次存放于表头节点所指向的单向链表中。

+ 无向图

![image-20220302152615119](https://s2.loli.net/2022/03/02/CaPMjHtDLOUVIqx.png)

+ 有向图

若是有向图，邻接表结构是类似的，但要注意的是有向图由于有方向的。因此，有向图的邻接表分为出边表和入边表（又称逆邻接表）

![image-20220302152754685](D:\桌面\P_picture_cahe\image-20220302152754685.png)

![image-20220302152805962](D:\桌面\P_picture_cahe\image-20220302152805962.png)



> 图的遍历是和树的遍历类似，我们希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次,这一过程就叫做图的遍历（Traversing Graph)。
>
> 树的遍历我们谈到了四种方案，应该说都还好,毕竟根结点只有一个，遍历都是从它发起，其余所有结点都只有一个双亲。可图就复杂多了，因为它的任一顶点都可能和其余的所有顶点相邻接，**极有可能存在沿着某条路径搜索后,又回到原顶点，而有些顶点却还没有遍历到的情况**。因此我们需要在遍历过程中把访问过的顶点打上标记，以避免访问多次而不自知。具体办法是设置一个**访问数组 visited[n]**,n是图中顶点的个数，初值为0，访问过后设置为1。这其实在小说中常常见到，一行人在迷宫中迷了路，为了避免找寻出路时屡次重复，所以会在路口用小刀刻上标记。对于图的遍历来说，如何避免因回路陷入死循环,就需要科学地设计遍历方案，通常有两种遍历次序方案:它们是深度优先遍历和广度优先遍历

### DFS

> DFS适合此类题目：给定初始状态跟目标状态，要求判断从初始状态到目标状态是否有解

**遍历无向图邻接矩阵**

```java

```

### 回溯

> 定义

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法。

假设当前局面下，我们有若干种选择，所以我们对每一种选择进行尝试。如果发现某种选择违反了某些限定条件，此时 return；如果尝试某种选择到了最后，发现该选择是正确解，那么就将其加入到解集中。在这种思想下，我们需要清晰的找出三个要素：选择 (Options)，限制 (Restraints)，结束条件 (Termination)

> 递归与回溯的区别与辨析

**递归是一种算法结构**。递归会出现在子程序中，形式上表现为直接或间接的自己调用自己，典型的例子是阶乘，计算规律为：n!=n×(n−1)!，代码表示如下

```java
int fac(int n) {
    if(n == 1) return n;
    else 
        return (n*fac(n - 1)); 
}
```

**回溯是一种算法思想**，它是用递归实现的。回溯的过程类似于穷举法，但回溯有“剪枝”功能，即自我判断过程。例如有求和问题，给定有 7 个元素的组合 [1, 2, 3, 4, 5, 6, 7]，求加和为 7 的子集。累加计算中，选择 1+2+3+4 时，判断得到结果为 10 大于 7，那么后面的 5, 6, 7 就没有必要计算了。这种方法属于搜索过程中的优化，即“剪枝”功能。

> 回溯算法可以解决的问题

除了以下这些问题，各种算法中也会用到递归，如快排，二分查找，分治算法等

+ 迷宫问题
+ 八皇后问题
+ 汉诺塔问题
+ 阶乘问题
+ 迷宫问题
+ 球和篮子的问题

这里列出迷宫问题和八皇后问题

**迷宫问题**

```java
import java.util.Arrays;

public class Maze {
    public static void main(String[] args) {
        //创建一个二维数组模拟迷宫
        //1代表墙，2代表轨迹，0代表可以进入
        int[][] map = new int[8][7];
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }
        for (int j = 1; j < 7; j++) {
            map[j][0] = 1;
            map[j][6] = 1;
        }
        for (int res[] :map){
            System.out.println(Arrays.toString(res)+" ");
        }
        //设置挡板, 1 表示
        map[3][1] = 1;
        map[3][2] = 1;
        System.out.println("===========");
        setWay(map, 1, 1);
		//展示走完后的路径，用数字2表示
       	for (int res[] :map){
           System.out.println(Arrays.toString(res)+" ");
       }
    }

    //使用递归回溯给小球找路
    //1. map 表示地图
    //2. i,j 表示从地图的哪个位置开始出发 (1,1)
    //3. 如果小球能到 map[6][5] 位置，则说明通路找到.
    //4. 约定： 当 map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通
    //5. 在走迷宫时，需要确定一个策略(方法) 下->右->上->左 , 如果该点走不通，再回溯

    /**
     * @param map 表示地图
     * @param i   从哪个位置开始找
     * @param j
     * @return 如果找到通路，就返回 true, 否则返回 false
     */
    public static boolean setWay(int[][] map, int i, int j) {
        if (map[6][5] == 2) { // 通路已经找到 ok
            return true;
        } else {
            if (map[i][j] == 0) { //如果当前这个点还没有走过
                //按照策略 下->右->上->左 走
                map[i][j] = 2; // 假定该点是可以走通.
                if (setWay(map, i + 1, j)) {//向下走
                    return true;
                } else if (setWay(map, i, j + 1)) { //向右走
                    return true;
                } else if (setWay(map, i - 1, j)) { //向上
                    return true;
                } else if (setWay(map, i, j - 1)) { // 向左走
                    return true;
                } else {
                    //说明该点是走不通，是死路
                    map[i][j] = 3;
                    return false;
                }
            } else { // 如果 map[i][j] != 0 , 可能是 1， 2， 3
                return false;
            }
        }
    }
}
```

**八皇后问题**

> 国际象棋中的皇后，可以横向、纵向、斜向移动。如何在一个8X8的棋盘上放置8个皇后，使得**任意两个皇后都不在同一条横线、竖线、斜线方向上**
>
> 解决八皇后问题，可以分为两个层面：
>
> 1.**找出第一种正确摆放方式**，也就是深度优先遍历（DFS）
>
> 2.**找出全部的正确摆放方式**，也就是广度优先遍历（BFS)

先简单提一下DFS和BFS

> BFS 常用于找单一的最短路线，它的特点是 "搜到就是最优解"，而 DFS 用于找所有解的问题，它的空间效率高，而且找到的不一定是最优解，必须记录并完成整个搜索，故一般情况下，深搜需要非常高效的剪枝（剪枝的概念请百度）

Java代码输出全部的摆放方式，以及对运行效率的分析

```

```

回溯

> 定义

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法。

假设当前局面下，我们有若干种选择，所以我们对每一种选择进行尝试。如果发现某种选择违反了某些限定条件，此时 return；如果尝试某种选择到了最后，发现该选择是正确解，那么就将其加入到解集中。在这种思想下，我们需要清晰的找出三个要素：选择 (Options)，限制 (Restraints)，结束条件 (Termination)

> 递归与回溯的区别与辨析

**递归是一种算法结构**。递归会出现在子程序中，形式上表现为直接或间接的自己调用自己，典型的例子是阶乘，计算规律为：n!=n×(n−1)!，代码表示如下

```java
int fac(int n) {
    if(n == 1) return n;
    else 
        return (n*fac(n - 1)); 
}
```

**回溯是一种算法思想**，它是用递归实现的。回溯的过程类似于穷举法，但回溯有“剪枝”功能，即自我判断过程。例如有求和问题，给定有 7 个元素的组合 [1, 2, 3, 4, 5, 6, 7]，求加和为 7 的子集。累加计算中，选择 1+2+3+4 时，判断得到结果为 10 大于 7，那么后面的 5, 6, 7 就没有必要计算了。这种方法属于搜索过程中的优化，即“剪枝”功能。

> 递归需要注意的问题

1. 尽量不使用递归
2. 当程序指定到一个方法时，就会开辟一个独立的栈，因此要会判断栈是否会溢出
3. 可以把递归理解为循环嵌套

> 回溯算法可以解决的问题

除了以下这些问题，各种算法中也会用到递归，如快排，二分查找，分治算法等

+ 迷宫问题
+ 八皇后问题
+ 汉诺塔问题
+ 阶乘问题
+ 迷宫问题
+ 球和篮子的问题

这里列出迷宫问题和八皇后问题

**迷宫问题**

```java
import java.util.Arrays;

public class Maze {
    public static void main(String[] args) {
        //创建一个二维数组模拟迷宫
        //1代表墙，2代表轨迹，0代表可以进入
        int[][] map = new int[8][7];
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }
        for (int j = 1; j < 7; j++) {
            map[j][0] = 1;
            map[j][6] = 1;
        }
        for (int res[] :map){
            System.out.println(Arrays.toString(res)+" ");
        }
        //设置挡板, 1 表示
        map[3][1] = 1;
        map[3][2] = 1;
        System.out.println("===========");
        setWay(map, 1, 1);
		//展示走完后的路径，用数字2表示
       	for (int res[] :map){
           System.out.println(Arrays.toString(res)+" ");
       }
    }

    //使用递归回溯给小球找路
    //1. map 表示地图
    //2. i,j 表示从地图的哪个位置开始出发 (1,1)
    //3. 如果小球能到 map[6][5] 位置，则说明通路找到.
    //4. 约定： 当 map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通
    //5. 在走迷宫时，需要确定一个策略(方法) 下->右->上->左 , 如果该点走不通，再回溯

    /**
     * @param map 表示地图
     * @param i   从哪个位置开始找
     * @param j
     * @return 如果找到通路，就返回 true, 否则返回 false
     */
    public static boolean setWay(int[][] map, int i, int j) {
        if (map[6][5] == 2) { // 通路已经找到 ok
            return true;
        } else {
            if (map[i][j] == 0) { //如果当前这个点还没有走过
                //按照策略 下->右->上->左 走
                map[i][j] = 2; // 假定该点是可以走通.
                if (setWay(map, i + 1, j)) {//向下走
                    return true;
                } else if (setWay(map, i, j + 1)) { //向右走
                    return true;
                } else if (setWay(map, i - 1, j)) { //向上
                    return true;
                } else if (setWay(map, i, j - 1)) { // 向左走
                    return true;
                } else {
                    //说明该点是走不通，是死路
                    map[i][j] = 3;
                    return false;
                }
            } else { // 如果 map[i][j] != 0 , 可能是 1， 2， 3
                return false;
            }
        }
    }
}
```

**八皇后问题**

> 国际象棋中的皇后，可以横向、纵向、斜向移动。如何在一个8X8的棋盘上放置8个皇后，使得**任意两个皇后都不在同一条横线、竖线、斜线方向上**
>
> 解决八皇后问题，可以分为两个层面：
>
> 1.**找出第一种正确摆放方式**，也就是深度优先遍历（DFS）
>
> 2.**找出全部的正确摆放方式**，也就是广度优先遍历（BFS)

先简单提一下DFS和BFS

> BFS 常用于找单一的最短路线，它的特点是 "搜到就是最优解"，而 DFS 用于找所有解的问题，它的空间效率高，而且找到的不一定是最优解，必须记录并完成整个搜索，故一般情况下，深搜需要非常高效的剪枝（剪枝的概念请百度）

Java代码输出全部的摆放方式，以及对运行效率的分析

:eight_spoked_asterisk:-广度优先遍历

代码实现

使用深度优先遍历邻接矩阵

```

```

### BFS

### 最短路径算法

> 单源点最短路径————Dijkstra算法
>
> 所有顶点间的最短路径————Floyd算法

#### Dijkstra算法

> 思路：按路径长度递增次序产生最短路径
>
> 代码构思：
>
> 1、假设给定一个顶点集合V,求到达某个顶点的最短路径
>
> 
>
> 2、定义一个boolean judge[V.length]来确定V中该顶点是否已经确定最短路径
>
> 
>
> 3、定义一个int dist[V.length]来初始化并动态更新源点到其他顶点的距离
>
> 4、
>
> ```java
> while(!judge[i]){//该点还未确定最短路径
>  min = Integer.MAX_VALUE;
>          for (从源点遍历整个集合V)  //循环找到从源点出发最近的距离
>              if (!judge[i] && dist[i] < min) {  
>                  //交换两数与下标
>              }
>  //可以确定离源点距离最近的一个点，V(源点) -- V(minIndex)
>  bj[minIndex] = true;
> 
>  //用这个点当中间点，找到 V(源点) -- V(minIndex) -- V(和V(minIdx)有边的点)，再一次更新最短路径
>          for () {//遍历和V（minIndex）有边的点
>              if (dist[i] == C)//如果该点到源点没有直达边，更新距离下··
>                  dist[i] = dist[minIdx] + map[minIdx][i];
>              //两边之和小于直达边，更新顶点到该边的距离
>              else if (dis[minIdx] + map[minIdx][i] < dis[i])
>                  //（V(0),minIndex) + (minIndex,V（k))   < (V(0),V(k))
>                  dist[i] = dist[minIdx] + map[minIdx][i];
>          }
> }
> ```
>
> 



> 步骤

1. 先确定从源点V(0)到各终点V(k)的直达路径，即通过一条边就可以到达的路径

2. 从这个路径找到一条长度最短的路径 （V(0),u)   **代码34-40行**

3. 对其余路径做出调整 **代码44-51行**

   若图中存在边 (u,V（k) ，且`（V(0),u) + (u,V（k) < (V(0),V(k))`,则以路径（V(0),u,V(k)）代替(V(0),V(k))

有点贪心的感觉，每次都寻找当前最优解

> 代码实现

```java
public class Main {
    //答案：10266837
    final static int C = 999999999;//定义该点无直达
    public static void main(String[] args) {
        //初始化邻接矩阵
        int[][] map = new int[2050][2050];
        //首先初始化为最大值
        for (int[] temp : map) {
            for (int i = 0; i < temp.length; i++) {
                temp[i] = C;
            }
        }
        //按照题意赋值
        for (int i = 1; i <= 2021; i++) {
            for (int j = i; j <= i + 21; j++) {
                //对a,b相差21以内的边赋权
                map[i][j] = lcm(i, j);
            }
        }
        //Dijkstra:按路径长度递增次序产生最短路径
        /*
        V:代表所有顶点
        bj:代表顶点是否已确定最短路径
        */
        boolean bj[] = new boolean[2050];//用来标记该点是否找到最短路径
        int dis[] = new int[2050];//存储源点到其他顶点的初始路径
        for (int i = 1; i <= 2021; i++)
            dis[i] = map[1][i];//先赋值为直达路径
        int min, minIdx = 0;
        //没执行一次while循环，确定到一个点的最短路径
        while (!bj[2021]) {//如果2021点的最短路径还没求到就一直循环
            min = Integer.MAX_VALUE;
            //每次找到从源点出发最近的距离
            for (int i = 2; i <= 2021; i++) {
                if (!bj[i] && dis[i] < min) {
                    //交换
                    min = dis[i];
                    minIdx = i;
                }
            }
            bj[minIdx] = true;//循环一圈以后，可以确定一个最短的点，然后进行下一次循环，直到bj[2021]==true

            //从最近的这个点当中间点，找到 V(0) -- V(minIdx) -- V(和V(minIdx)有直连的点)，再一次更新最短路径
            for (int i = minIdx + 1; i <= minIdx + 21; i++) {
                //如果该点到源点没有边
                if (dis[i] == C)
                    dis[i] = dis[minIdx] + map[minIdx][i];
                //两边之和小于直达边，更新距离
                else if (dis[minIdx] + map[minIdx][i] < dis[i])
                    dis[i] = dis[minIdx] + map[minIdx][i];
            }
        }
        System.out.println(dis[2021]);
    }

    //求最大公约数
    public static int gcd(int x, int y) {
        if (y == 0)
            return x;
        return gcd(y, x % y);
    }
    public static int lcm(int x, int y) {//最小公倍数
        return x * y / gcd(x, y);
    }

}
```



#### Floyd算法













## 数论

### 分解质因数

```java
	for (long i = 1; i * i <= n; i++) {//求所有公因子的方法 很大程度上提高了效率
            if (n % i == 0) {
                list.add(i);
                if (i != n / i) {
                    list.add(n / i);
                }
            }
        }
```



### 筛素数

```javascript
if（num%4==0&&num%100!=0||num%400==0)
```



### 回文数



### 最大公约数与最小公倍数

欧几里德算法又称辗转相除法，用于计算两个整数a,b的最大公约数`GCD(greatest common divisor)`。其计算原理依赖于下面的定理：

定理：gcd(a,b) = gcd(b,a mod b)

```java
int Gcd(int a, int b)
{
    if(b == 0)
        return a;
    return Gcd(b, a % b);
}
```

> 利用最大公约数求最小公倍数

两个数的乘积等于这两个数的最大公约数与最小公倍数的乘积。假设有两个数是a、b，它们的最大公约数是p，最小公倍数是q。那么存在这样的关系式：ab=pq





## 前缀和

**前缀和技巧适用于快速、频繁地计算一个索引区间内的元素之和**







