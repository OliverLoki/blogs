   



常用算法思想+具体问题分析+Java代码实现

## 算法的时间复杂度与空间复杂度

**度量一个程序(算法)效率的两种方法**

1、 事后统计的方法
这种方法可行, 但是有两个问题：一是需要实际运行测试该算法；二是依赖于计算机的硬件、软件等环境因素
2、 事前估算的方法
通过分析某个算法的<u>时间复杂度</u>来判断哪个算法更优

### 时间复杂度

> **定义**



> **计算时间复杂度的方法**

1. 用常数1代替运行时间中的所有加法常数
2. 修改后的运行次数函数中，只保留最高阶项
3. 去除最高阶项的系数

> **常见的时间复杂度**

![image-20211102180341692](https://i.loli.net/2021/11/02/6W2ViPoesFErmAf.png)

常见的算法时间复杂度由小到大依次为: 

O(1) < O(logN) < O(n) < O(nlogN) < O(n^2) < O(n^3) < O(n^k) < O(2^n)

随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低

### 空间复杂度

空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度



### 二者的关系

对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。算法的时间复杂度和空间复杂度合称为算法的复杂度。



## 排序算法

> 各算法复杂度、稳定性和适用场景

- **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
- **不稳定**：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
- **时间复杂度**: 对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
- **空间复杂度：**是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数

![image-20211102210341125](https://i.loli.net/2021/11/02/W2lpvHhcNOg56Ru.png)

### 最佳实践

在大多数实际情况中，快速排序是最佳选择，但是当为实际应用开发应用程序时，你会发现Java的

`Arrays.sort()`实现已经基本够用了，因为它使用的三向快速排序和归并排序都是经典

> 对于 java.util.Arrays.sort(),根据不同的参数类型，实际上每种原始数据类型都有一个不同的排序方法，感兴趣可以自行阅读源码

### 冒泡排序

> 逆序数等于一个序列要变成**升序排列**所需要的**相邻元素**交换的**最小**次数（仅适用于冒泡排序）

冒泡排序是一种简单的排序算法,不管原始数组是否有序，**时间复杂度都是O（n^2）**，

对于拥有N个字母的字符串，最多需要交换N*(N-1)/2次

**算法描述**

比较相邻的元素。如果第一个比第二个大，就交换它们两个，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数,因此要搞懂需要比较的次数便成为了一个难点

并且原始的冒泡排序并不高效，可以自行搜索冒泡排序的优化，但总的来说，除非数据量很小，否则一般不推荐冒泡排序

**动图演示**

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif)

**Java代码**

```java
//冒泡排序
    public static void bubbleSort(int[] arr) {
        long startTime = System.currentTimeMillis();   //获取开始时间
        for (int i = 0; i < arr.length - 1; i++) {
            //i可以理解为最后已经排好序的元素的个数
            for (int j = 0; j < arr.length - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    //通过位运算交换两数字
                    arr[j] ^= arr[j + 1];
                    arr[j + 1] ^= arr[j];
                    arr[j] ^= arr[j + 1];
                }
            }
        }
        long endTime = System.currentTimeMillis(); //获取结束时间
        System.out.println("程序运行时间： " + (endTime - startTime) + "ms");
    }
```

### 选择排序

**算法描述**

选择排序(Selection-sort)是一种<u>简单直观</u>的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕

**动图演示**

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif)

**Java代码**

```java
public static void selectionSort(int[] arr) {
        long startTime = System.currentTimeMillis();   //获取开始时间
        int minIndex;
        for (int i = 0; i < arr.length - 1; i++) {
            minIndex = i;
            for (int j = i + 1; j < arr.length - 1; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            arr[i]^=arr[minIndex];
            arr[minIndex]^=arr[i];
            arr[i]^=arr[minIndex];
        }
        long endTime = System.currentTimeMillis(); //获取结束时间
        System.out.println("程序运行时间： " + (endTime - startTime) + "ms");
    }
```

### 快速排序！

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif)

> 关键词：分治、递归、双向扫描

**算法描述**

基本思想就是选取一个基准，一趟排序确定两个区间，一个区间全部比基准值小，另一个区间全部比基准值大，接着再选取一个基准值来进行排序，以此类推，最后得到一个有序的数列。

> 具体算法描述如下

快速排序分为大体可以分为两步：

1. 切分操作

   从数列中挑出一个元素，称为 “基准”（pivot），重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作

2. 递归排序

   **递归调用**快速排序的函数对两个区间再进行以上操作，直到调用的区间为空或是只有一个数,《算法4》中指出，用归纳法可以证明递归能够正确的将数组进行排序

```java
	public static void quickSort(int[] arr,int low, int high){
		if(hi<=lo)   return;
    	int piovt = partition(arr,low,high);//分区操作
        quickSort(aee,low,pivot-1);
        quickSort(arr,pivot+1,hi)
    }
```

> 切分操作指南--双指针双向扫描
>
> 定义一个基准pivot(这个基准最好是处于这个待排序数组的中间值附近)，在快排中，[选择一个好的中轴选择策略会使算法的效率显著提高](https://blog.csdn.net/ljianhui/article/details/16797431)，我们定义arr[0]为pivot,然后
>
> 1. 先从最右位置往左开始找直到找到一个小于基准数的值，记录下该值的位置（记作 **i**）
> 2. 再从最左位置往右找直到找到一个大于基准数的值，记录下该值的位置（记作 **j**）
> 3. 如果位置i<j，则交换i和j两个位置上的值，然后继续从**(j-1)的位置往前**和**(i+1)的位置往后**重复上面比对基准数然后交换的步骤
> 4. 如果执行到i==j，表示本次比对已经结束，将最后i的位置的值与基准数做交换，此时基准数就找到了临界点的位置k，位置k两边的数组都比当前位置k上的基准值或都更小或都更大
> 5. 上一次的基准值7已经把数组分为了两半，**基准值算是已归位（找到排序后的位置）**

快排代码

```java

public static int[] sort(int[] ins ,int start,int end) {
        if (start >= end) {
            return ins;//这个返回值并没有影响，因为这个返回值没有使用到。
        }
        int pivot = ins[start];//定义基准
        int low = start;
        int hight = end;

        while (low < hight) {
            while (low < hight && ins[hight] >= pivot) {//从右边开始找一个小于mid的数
                hight -= 1;
            }
            ins[low] = ins[hight];//找到以后与基准交换

            while (low < hight && ins[low] < pivot) {//从左开始找一个大于mid的数
                low += 1;
            }
            ins[hight] = ins[low];//交换
        }
        ins[low] = pivot;//当low>=height时，停止查找，将基准归位

        sort(ins, start, low - 1);
        sort(ins, low + 1, end);
        return ins;
    }
```

### 插入排序

**算法描述**

插入排序（Insertion Sorting）的基本思想是: 把 n 个待排序的元素看成为一个有序表和一个无序表，开始时 有序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，寻找合适的插入位置

**动图演示**

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif)

**Java代码**

```java
	public static void insertSort(int[] arr) {
        long startTime = System.currentTimeMillis();   //获取开始时间
        //假定第i个元素有序,i=1，这个for循环说明了n个数的数组需要遍历n-1次
        for (int i = 1; i < arr.length; i++) {
            int preIndex = i - 1; //定义
            int current = arr[i]; //定义待插入的数
            //遍历有序列表找到合适的插入位置
            while (preIndex >= 0 && arr[preIndex] > current) {
                arr[preIndex + 1] = arr[preIndex];
                preIndex--;
            }
            arr[preIndex + 1] = current;
        }
        long endTime = System.currentTimeMillis(); //获取结束时间
        System.out.println("程序运行时间： " + (endTime - startTime) + "ms");
    }
```

### 希尔排序

首先思考一下插入排序存在的问题==》当需要插入的数是较小的数时， 后移的次数明显增多，对 效率有影响.

希尔排序也是一种插入排序，1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序经过改进之后的一个 更高效的版本，也称为**缩小增量排序**

**算法描述**

​	希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止

​	简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。

　　而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。

**动图演示**

![](https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190420100142756-421005088.gif)

**Java代码**

```java
	public static void shellSort(int[] arr) {
        long startTime = System.currentTimeMillis();   //获取开始时间
        //控制增量序列,增量序列为1的时候为最后一趟
        for (int i = arr.length / 2; i > 0; i /= 2) {
            //根据增量序列，找到每组比较序列的最后一个数的位置
            for (int j = i; j < arr.length; j++) {
                //根据该比较序列的最后一个数的位置，依次向前执行插入排序
                for (int k = j - i; k >= 0; k -= i) {
                    if (arr[k] > arr[k + i]) {
                        arr[k] ^= arr[k + i];
                        arr[k + i] ^= arr[k];
                        arr[k] ^= arr[k + i];
                    }
                }
            }
        }
        long endTime = System.currentTimeMillis(); //获取结束时间
        System.out.println("希尔排序运行时间： " + (endTime - startTime) + "ms");
    }
```

**算法分析**

希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的

### 归并排序

**算法描述**

归并排序就是递归得将原始数组递归对半分隔，直到不能再分（只剩下一个元素）后，开始从最小的数组向上归并排序

1. 向上归并排序的时候，需要一个**暂存数组**用来排序，

2. 将待合并的两个数组，从第一位开始比较，小的放到暂存数组，指针向后移，

3. 直到一个数组空，这时，不用判断哪个数组空了，直接将两个数组剩下的元素追加到暂存数组里，

4. 再将暂存数组排序后的元素放到原数组里，两个数组合成一个，这一趟结束

**动图演示**

![](https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190326201207440-689679432.gif)

![](https://s3.bmp.ovh/imgs/2021/11/cc5199afca786911.png)



**Java代码**

```java

```



### 基数排序



### 堆排序



## 查找算法

> 序

​	首先我们要弄清楚查找表、记录、关键字、主关键字、静态查找表、动态查找表等这些概念。
然后，对于**顺序查找**来说，尽管很土（简单)，但它却是后面很多查找的基础。
​	有序查找，着重了解**二分查找**的思想，它在性能上比原来的顺序查找有了质的飞跃，时间复杂度由`O(n)`变成了`O(logN)`。之后我们又讲解了另外两种优秀的有序查找:**插值查找**和斐波那契查找,三者各有优缺点,望大家要仔细体会。
​	二叉排序树是动态查找最重要的数据结构，它可以在兼顾查找性能的基础上，让插入和删除也变得效率较高。不过为了达到最优的状态，二叉排序树最好是构造成平衡的二叉树才最佳。因此我们就需要再学习关于平衡二叉树(AVL 树）的数据结构，了解AVL树是如何处理平衡性的问题。这部分是本章重点，需要认真学习掌握。
​	B树这种数据结构是针对内存与外存之间的存取而专门设计的。由于内外存的查找性能更多取决于读取的次数，因此在设计中要考虑B树的平衡和层次。我们讲解时是先通过最最简单的B树(2-3树)来理解如何构建、插入、删除元素的操作，再通过2-3-4树的深化,最终来理解B树的原理。之后,我们还介绍了B+树的设计思想。
​	散列表是一种非常高效的查找数据结构，在原理上也与前面的查找不尽相同，它回避了关键字之间反复比较的烦琐，而是直接一步到位查找结果。当然，这也就带来了记录之间没有任何关联的弊端。应该说，散列表对于那种查找性能要求高，记录之间关系无要求的数据有非常好的适用性。在学习中要注意的是散列函数的选择和处理冲突的方法。





### 二分查找

> 二分查找是对于**有序列表**的查找技术，如果是无序的则要先进行排序操作，相对于顺序查找(就是for循环一个个遍历)，时间复杂度有了质的提升，由O(n)变为O(logN)

> **折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要**频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用，对于动态查找表，可以考虑二叉排序树的查找技术
>
> ​			                                     ——《大话数据结构》

> 另外比较优秀的有序查找算法为 **插值查找**、**斐波那契查找**，三者各有优缺点，可以自行了解，仔细体会

**算法思想**

二分查找的思想非常简单，有点类似分治的思想。二分查找针对的是一个有序的数据集合，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0

![image-20211104162536005](https://i.loli.net/2021/11/04/w5T8OfHigALlEvy.png)

**Java代码**

递归实现

```java
	/**
     * @param arr 被排序数组
     * @param left 查找起始位置
     * @param right 查找结束位置
     * @param findVal 需要查找的值
     */

    public static void binarySearch(int[] arr, int left, int right, int findVal) {
        int mid = (left + right) / 2;
        if (arr[mid] < findVal) //向右递归
            binarySearch(arr,mid+1,arr.length-1,findVal);
        if (arr[mid] > findVal) //向左递归
            binarySearch(arr,left,mid-1,findVal);       
        if (arr[mid] == findVal){//找到索引值,扫描其左右侧
            List<Integer> list = new ArrayList<Integer>();
            //扫描左侧
            for (int i = left; i < mid; i++) {
                if (arr[i]==findVal)
                    list.add(i);
            }
            //扫描右侧
            for (int i = mid; i < right; i++) {
                if (arr[i]==findVal)
                    list.add(i);
            }
            System.out.println(findVal + " 二分查找的索引值为:" + list);
        }
    }
```

非递归

```java
		public static void binarySearch2(int[] arr, int left, int right, int findVal){
        while(left <= right) { //说明继续查找
            int mid = (left + right) / 2;
            if(arr[mid] == findVal) {
                System.out.println("二分非递归索引位置："+mid);
                break;
            } else if ( arr[mid] > findVal) {
                right = mid - 1;//需要向左边查找
            } else {
                left = mid + 1; //需要向右边查找
            }
        }

    }
```



### 插值查找

​	在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？

　　打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。

​	经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：

　　`mid=(low+high)/2, 即mid=low+1/2*(high-low)`;

　　通过类比，我们可以将查找的点改进为如下：

　　`mid=low+(value-a[low])/(a[high]-a[low])*(high-low)`

也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。

**算法思想**

基于二分查找算法，将查找点的选择改进为自适应选择,插值查找的核心是插的计算公式，可以提高查找效率。当然，差值查找也属于有序查找

> 注：**对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。**

**Java代码**

```java
public static int insertValueSearch(int[] arr, int left, int right, int findVal) {
        //注意：findVal < arr[0] 和 findVal > arr[arr.length - 1] 必须需要
        //否则我们得到的 mid 可能越界
        if (left > right || findVal < arr[0] || findVal > arr[arr.length - 1]) {
            return -1;
        }
        // 求出 mid, 自适应
        int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);
        int midVal = arr[mid];
        if (findVal > midVal) { // 说明应该向右边递归
            return insertValueSearch(arr, mid + 1, right, findVal);
        } else if (findVal < midVal) { // 说明向左递归查找
            return insertValueSearch(arr, left, mid - 1, findVal);
        } else {
            return mid;
        }
    }
```



> 以上两种比较高效的查找方法都是基于有序的基础之上的,但事实上，很多数据集可能增长非常快，例如，某些微博网站或大型论坛的帖子和回复总数每天都是成百万上千万条，如图8-5-1所示，或者一些服务器的日志信息记录也可能是海量数据，要保证记录全部是按照当中的某个关键字有序，其时间代价是非常高昂的，所以这种数据通常都是按先后顺序存储。
>
> 那么对于这样的查找表，我们如何能够快速查找到需要的数据呢?办法就是---**索引**
>
> 对于线性索引查找（本文并未涉及）,可以自行了解**稠密索引**、**分块索引**和**倒排索引**。索引技术被广泛的用于文件检索、数据库和搜索引擎等技术领域，是进一步学习这些技术的基础。

### 散列表查找（哈希表）概述

通过之前的查找我们发现，为了查找到结果，“比较”是不可避免的，但这是否真的有必要?

能否直接通过关键字key得到要查找的记录内存存储位置呢



==》这就引出了一种存储结构——散列表



![image-20211104194840702](https://i.loli.net/2021/11/04/1IyxprqNhKOElzu.png)



> 散列函数的设计



## 递归与分治

### 递归与分治的定义

> 递归定义

+ 程序调用自身的编程技巧称为递归（ recursion）
+ **递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量**
+ 递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解

> 分治定义

**核心思想：减小问题的规模，抽象步骤并一般化**

在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)



### 如何设计算法

> 如何设计一个递归

1. 找重复子问题： n*(n-1)的阶乘,求n-1的阶乘是原问题的重复，也可以理解为规模更小的子问题
   1. 找到一种划分方法
   2. 找到递推公式或者等价转换
2. 找变化量：找到变化的参数，传入形参，通过这个参数来结束递归
3. 找边界：递归结束的条件

> **依据分治法设计程序时的思维过程**

实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序

1、一定是先找到最小问题规模时的求解方法

2、然后考虑随着问题规模增大时的求解方法

3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可



这样说可能会有点空洞，我们来看下面几个例子

> 简单的递归--切蛋糕思维

+ 递归求一个数的阶乘

  ```javascript
  	static int factorial(int num){
          if (num==1)
              return 1;
          return num*factorial(num-1);
      }
  ```

+ 递归求最大公约数————GCD算法

  ```java
  	static int factorial(int num){
          if (num==1)
            return 1;
          return num*factorial(num-1);
      }
  ```

+ 对arr的所有元素求和

  ```java
   	static int sum(int[] arr,int begin){
          if(begin = arr.length()-1)//当begin是最后一个元素
              return arr[begin];//返回begin即可
          return arr[begin] + sum(arr,begin+1);
      }
  ```

+ 翻转字符串

  ```java
   	//翻转字符串
      static String reverse(String str,int endIndex){
          return str.charAt(endIndex)+reverse(str,endIndex-1);
      }
  ```

> 难一点的递归--等价转换，找递推公式

+ 斐波那契数列

```java
	static int fib(int num) {//这个数字是指递归的次数，和斐波那契数本身没有关系
        if (num == 1 || num == 2)
            return 1;
        return fib(num - 1) + fib(num - 2);
    }
```

+ 最大公因数

```java
	static int gcd(int x, int y) {
        if (y == 0)
            return x;
        return gcd(y, x % y);
    }
```



> 递归需要注意的问题

1. 尽量不使用递归
2. 当程序指定到一个方法时，就会开辟一个独立的栈，因此要会判断栈是否会溢出
3. 可以把递归理解为循环嵌套

### 汉诺塔问题

**汉诺塔是递归 + 分治思想的体现**

先来看题目

> 汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间**一次只能移动一个圆盘**。
> 假如每秒钟一次，共需多长时间呢？移完这些圆盘需要 5845.54 亿年以上，太阳系的预期寿命据说也就是数百亿年。真的过了 5845.54 亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。

这是一个简单的汉诺塔模型（只有三个圆盘）

**问题描述**：

给定一个n，说明A柱有n个数字的圆盘，按找汉诺塔的规则，将圆盘移动到B柱,解法如下

<img src="https://www.biancheng.net/uploads/allimg/201202/2-2012021AUKS.gif" style="zoom:150%;" />



> 分治思想的体现
>
> 而对于复杂的汉诺塔模型，我们可以把做看作两部分
>
> 1.最下边的一个盘
>
> 2.上面的所有盘（又可以看作两部分来处理）
>
> 要解决n个，先解决n-1个，**可以分治为n=1和n>=2的最简单情况并加以解决**
>

> 递归思想的体现
>
> 将N个圆盘从A柱移动到B柱
>
> ​	等价于
>
> ​	1、将N-1个圆盘移动到C柱，B柱为辅助柱
>
> ​	2、将第N个圆盘移动到B柱
>
> ​	3、将N-1个圆盘移动到B柱，A柱为辅助柱
>
> 
>
> 递归变化量：每个子问题移动的柱子在减少
>
> 递归结束条件：当圆盘数量=1时，将这个圆盘放在最上方即可

**Java代码**

```java
/**
     * 打印将N个盘子移动到目标盘的路径
     *
     * @param num  圆盘个数
     * @param from 初始柱子
     * @param help 辅助柱子
     * @param to   目标柱子
     */
static void hanoiTower(int num, char from, char to, char help) {
        if (num == 1) {
            System.out.println("第1个盘从" + from + "->" + to);
        } else {//n >= 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘
            hanoiTower(num - 1, from, help, to);
            //最下面的到目标柱子
            System.out.println("第" + num + "个盘从 " + from + "->" + to);
            //让N-1回到初始柱子
            hanoiTower(num - 1, help, to, from);
        }
    }
```

### 小结

使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。这里我列举了几道算法题目，这几道算法题目都可以用递归轻松写出来：

- 递归实现 sum
- 二叉树的遍历
- 走楼梯问题
- 汉诺塔问题
- 杨辉三角

递归中**如果**存在重复计算（我们称重叠子问题，下文会讲到），那就是使用记忆化递归（或动态规划）解题的强有力信号之一。可以看出动态规划的核心就是使用记忆化的手段消除重复子问题的计算，如果这种重复子问题的规模是指数或者更高规模，那么记忆化递归（或动态规划）带来的收益会非常大。

为了消除这种重复计算，我们可使用查表的方式。即一边递归一边使用“记录表”（比如哈希表或者数组）记录我们已经计算过的情况，当下次再次碰到的时候，如果之前已经计算了，那么直接返回即可，这样就避免了重复计算。下文要讲的**动态规划中 DP 数组其实和这里“记录表”的作用是一样的**。

如果你刚开始接触递归， 建议大家先去练习一下递归再往后看。一个简单练习递归的方式是将你写的迭代全部改成递归形式。比如你写了一个程序，功能是“将一个字符串逆序输出”，那么使用迭代将其写出来会非常容易，那么你是否可以使用递归写出来呢？通过这样的练习，可以让你逐步适应使用递归来写程序。

当你已经适应了递归的时候，那就让我们继续学习动态规划吧！

## 动态规划

### 算法思想

动态规划（Dynamic programming）是一个从其他行业借鉴过来的词语。

它的大概意思先将一件事情分成**若干阶段**，然后通过阶段之间的**转移**达到目标。由于转移的方向通常是多个，因此这个时候就需要**决策**选择具体哪一个转移方向

1. 阶段之间可以进行转移，这叫做动态
2. 达到一个**可行解(目标阶段)** 需要不断地转移，那如何转移才能达到**最优解**？这叫规划



:factory:**如果你没有模拟所有可能，而直接走了一条最优解，那就是贪心算法了**

### 可解决的问题

> 背包问题

+ 01背包
+ 完全背包

> 求最大连续和问题

[剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)最佳实践为动态规划



**问题描述**

问题描述：给定一个序列（整数或浮点数），求出其中连续的子序列和最大的那一个。

例：序列{-10 1 2 3 4 -5 -23 3 7 -21}，其最大的连续子序列为{1 2 3 4}或{3 7}，最大和为10.



**解法一：暴力求解--最基本的思路 时间复杂度 O(n^3)**

最普通的方法，效率十分低，一般不会用到，这里简单介绍。直接两个for循环枚举子序列的首尾，再来一个for循环计算首尾之间的序列和，计算所有的序列和，找到最大值。

效率是相当的低，附代码仅供参考，但是oj千万别这样写，肯定会有较大数据测试

```java
	public static int violentSolution(int[] nums) {
        ArrayList<Integer> list = new ArrayList<>();
        if (nums.length == 1) {
            return nums[0];
        }
        //注意对条件的判断
        for (int i = 0; i <= nums.length - 1; i++) {
            int sum = 0;
            for (int j = 0; j < nums.length - i; j++) {
                //加几个数
                sum += nums[i + j];
                list.add(sum);
            }
        }
        return Collections.max(list);
    }
```



> 解法二：预处理暴力求解 时间复杂度 O(n^2)

第一种方法为什么这么慢，原因之一是每次都要计算首尾之间的序列和。

基于这个考虑，我们可以对数据进行预先处理：读入数据时使用一个数组SUM[i]来记录前i项数据之和。

用这种方法，只需要两个for循环枚举子序列的首尾，利用SUM数组计算子序列和，找到最大值。



时间复杂度：O(n^2)，还是很糟糕，建议不要用。（这个就不贴代码了）



> 解法三：前缀和思想 复杂度O(n)
>
> 前缀和思想和滑动窗口会经常用在求子数组和子串问题上

```java
	//前缀和思想
    public int maxSubArray(int[] nums) {
        int preSum = 0;
        int minSum = 0;
        int maxSubSum = Integer.MIN_VALUE;
        for (int num : nums) {
            preSum += num;
            maxSubSum = Math.max(maxSubSum, preSum - minSum);
            minSum = Math.min(minSum, preSum);
        }
        return maxSubSum;
    }
```



> 解法四：动态规划--- 最佳实践 时间复杂度 O(n)

```

```







### 浅谈分治与动态规划

分治和动态规划有相似之处也有不同，我们来看如下两个定义。

> 最优子结构：如果问题的一个最优解中包含了子问题的最优解，则该问题具有最优子机构。

> 重叠子问题：用来求解原问题的递归算法反复地解同样的子问题，而不是总是在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。

> 动态规划要求其子问题既要独立又要重叠，这看上去似乎有些奇怪。虽然这两点要求听起来可能矛盾的，但它们描述了两种不同的概念，而不是同一个问题的两个方面。如果同一个问题的两个子问题不共享资源，则它们就是独立的。对两个子问题俩说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。
>
> ​													————————算法导论

当子问题相互独立时，能且只能使用分治。

存在重叠子问题时，动态规划是更好的算法。 

综上，

分治法 ——》 各子问题独立

动态规划 ——》 各子问题重叠



## 贪心算法





## 字符串

### KMP算法





## 图论

主要涉及到图的遍历算法，学习算法前应该首先了解图的存储形式

### 图的存储结构

图的存储结构除了要存储图中的各个顶点本身的信息之外，还要存储顶点与顶点之间的关系，因此，图的结构也比较复杂。常用的图的存储结构有邻接矩阵和邻接表等

> 二维数组表示---邻接矩阵

图的**邻接矩阵**（Adjacency Matrix）存储方式是**用两个数组来表示图**。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息

+ 无向图

  无向图的边数组是一个对称矩阵

![image-20220302152448487](https://s2.loli.net/2022/03/02/egpWmAfdDGC62Mk.png)

+ 有向图

![image-20220302152513755](https://s2.loli.net/2022/03/02/8jN6AF2VOHQPMtf.png)

由于存在n个顶点的图需要n*n个数组元素进行存储，**当图为稀疏图时，使用邻接矩阵存储方法将会出现大量0元素，这会造成极大的空间浪费**。这时，可以考虑使用邻接表表示法来存储图中的数据

> 链表表示---邻接表

首先，回忆我们在线性表时谈到，顺序存储结构就存在预先分配内存可能造成存储空间浪费的问题，于是引出了链式存储的结构。同样的，我们也可以考虑对边或弧使用链式存储的方式来避免空间浪费的问题。       

邻接表由**表头节点**和**表节点**两部分组成，图中每个顶点均对应一个存储在数组中的表头节点。如果这个表头节点所对应的顶点存在邻接节点，则把邻接节点依次存放于表头节点所指向的单向链表中。

+ 无向图

![image-20220302152615119](https://s2.loli.net/2022/03/02/CaPMjHtDLOUVIqx.png)

+ 有向图

若是有向图，邻接表结构是类似的，但要注意的是有向图由于有方向的。因此，有向图的邻接表分为出边表和入边表（又称逆邻接表）

![image-20220302152754685](D:\桌面\P_picture_cahe\image-20220302152754685.png)

![image-20220302152805962](D:\桌面\P_picture_cahe\image-20220302152805962.png)



> 图的遍历是和树的遍历类似，我们希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次,这一过程就叫做图的遍历（Traversing Graph)。
>
> 树的遍历我们谈到了四种方案，应该说都还好,毕竟根结点只有一个，遍历都是从它发起，其余所有结点都只有一个双亲。可图就复杂多了，因为它的任一顶点都可能和其余的所有顶点相邻接，**极有可能存在沿着某条路径搜索后,又回到原顶点，而有些顶点却还没有遍历到的情况**。因此我们需要在遍历过程中把访问过的顶点打上标记，以避免访问多次而不自知。具体办法是设置一个**访问数组 visited[n]**,n是图中顶点的个数，初值为0，访问过后设置为1。这其实在小说中常常见到，一行人在迷宫中迷了路，为了避免找寻出路时屡次重复，所以会在路口用小刀刻上标记。对于图的遍历来说，如何避免因回路陷入死循环,就需要科学地设计遍历方案，通常有两种遍历次序方案:它们是深度优先遍历和广度优先遍历

### DFS-深度优先遍历

> DFS适合此类题目：给定初始状态跟目标状态，要求判断从初始状态到目标状态是否有解

**遍历无向图邻接矩阵**

```java

```

### 回溯

> 定义

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法。

假设当前局面下，我们有若干种选择，所以我们对每一种选择进行尝试。如果发现某种选择违反了某些限定条件，此时 return；如果尝试某种选择到了最后，发现该选择是正确解，那么就将其加入到解集中。在这种思想下，我们需要清晰的找出三个要素：选择 (Options)，限制 (Restraints)，结束条件 (Termination)

> 递归与回溯的区别与辨析

**递归是一种算法结构**。递归会出现在子程序中，形式上表现为直接或间接的自己调用自己，典型的例子是阶乘，计算规律为：n!=n×(n−1)!，代码表示如下

```java
int fac(int n) {
    if(n == 1) return n;
    else 
        return (n*fac(n - 1)); 
}
```

**回溯是一种算法思想**，它是用递归实现的。回溯的过程类似于穷举法，但回溯有“剪枝”功能，即自我判断过程。例如有求和问题，给定有 7 个元素的组合 [1, 2, 3, 4, 5, 6, 7]，求加和为 7 的子集。累加计算中，选择 1+2+3+4 时，判断得到结果为 10 大于 7，那么后面的 5, 6, 7 就没有必要计算了。这种方法属于搜索过程中的优化，即“剪枝”功能。

> 回溯算法可以解决的问题

除了以下这些问题，各种算法中也会用到递归，如快排，二分查找，分治算法等

+ 迷宫问题
+ 八皇后问题
+ 汉诺塔问题
+ 阶乘问题
+ 迷宫问题
+ 球和篮子的问题

这里列出迷宫问题和八皇后问题

**迷宫问题**

```java
import java.util.Arrays;

public class Maze {
    public static void main(String[] args) {
        //创建一个二维数组模拟迷宫
        //1代表墙，2代表轨迹，0代表可以进入
        int[][] map = new int[8][7];
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }
        for (int j = 1; j < 7; j++) {
            map[j][0] = 1;
            map[j][6] = 1;
        }
        for (int res[] :map){
            System.out.println(Arrays.toString(res)+" ");
        }
        //设置挡板, 1 表示
        map[3][1] = 1;
        map[3][2] = 1;
        System.out.println("===========");
        setWay(map, 1, 1);
		//展示走完后的路径，用数字2表示
       	for (int res[] :map){
           System.out.println(Arrays.toString(res)+" ");
       }
    }

    //使用递归回溯给小球找路
    //1. map 表示地图
    //2. i,j 表示从地图的哪个位置开始出发 (1,1)
    //3. 如果小球能到 map[6][5] 位置，则说明通路找到.
    //4. 约定： 当 map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通
    //5. 在走迷宫时，需要确定一个策略(方法) 下->右->上->左 , 如果该点走不通，再回溯

    /**
     * @param map 表示地图
     * @param i   从哪个位置开始找
     * @param j
     * @return 如果找到通路，就返回 true, 否则返回 false
     */
    public static boolean setWay(int[][] map, int i, int j) {
        if (map[6][5] == 2) { // 通路已经找到 ok
            return true;
        } else {
            if (map[i][j] == 0) { //如果当前这个点还没有走过
                //按照策略 下->右->上->左 走
                map[i][j] = 2; // 假定该点是可以走通.
                if (setWay(map, i + 1, j)) {//向下走
                    return true;
                } else if (setWay(map, i, j + 1)) { //向右走
                    return true;
                } else if (setWay(map, i - 1, j)) { //向上
                    return true;
                } else if (setWay(map, i, j - 1)) { // 向左走
                    return true;
                } else {
                    //说明该点是走不通，是死路
                    map[i][j] = 3;
                    return false;
                }
            } else { // 如果 map[i][j] != 0 , 可能是 1， 2， 3
                return false;
            }
        }
    }
}
```

**八皇后问题**

> 国际象棋中的皇后，可以横向、纵向、斜向移动。如何在一个8X8的棋盘上放置8个皇后，使得**任意两个皇后都不在同一条横线、竖线、斜线方向上**
>
> 解决八皇后问题，可以分为两个层面：
>
> 1.**找出第一种正确摆放方式**，也就是深度优先遍历（DFS）
>
> 2.**找出全部的正确摆放方式**，也就是广度优先遍历（BFS)

先简单提一下DFS和BFS

> BFS 常用于找单一的最短路线，它的特点是 "搜到就是最优解"，而 DFS 用于找所有解的问题，它的空间效率高，而且找到的不一定是最优解，必须记录并完成整个搜索，故一般情况下，深搜需要非常高效的剪枝（剪枝的概念请百度）

Java代码输出全部的摆放方式，以及对运行效率的分析

```

```

回溯

> 定义

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法。

假设当前局面下，我们有若干种选择，所以我们对每一种选择进行尝试。如果发现某种选择违反了某些限定条件，此时 return；如果尝试某种选择到了最后，发现该选择是正确解，那么就将其加入到解集中。在这种思想下，我们需要清晰的找出三个要素：选择 (Options)，限制 (Restraints)，结束条件 (Termination)

> 递归与回溯的区别与辨析

**递归是一种算法结构**。递归会出现在子程序中，形式上表现为直接或间接的自己调用自己，典型的例子是阶乘，计算规律为：n!=n×(n−1)!，代码表示如下

```java
int fac(int n) {
    if(n == 1) return n;
    else 
        return (n*fac(n - 1)); 
}
```

**回溯是一种算法思想**，它是用递归实现的。回溯的过程类似于穷举法，但回溯有“剪枝”功能，即自我判断过程。例如有求和问题，给定有 7 个元素的组合 [1, 2, 3, 4, 5, 6, 7]，求加和为 7 的子集。累加计算中，选择 1+2+3+4 时，判断得到结果为 10 大于 7，那么后面的 5, 6, 7 就没有必要计算了。这种方法属于搜索过程中的优化，即“剪枝”功能。

> 递归需要注意的问题

1. 尽量不使用递归
2. 当程序指定到一个方法时，就会开辟一个独立的栈，因此要会判断栈是否会溢出
3. 可以把递归理解为循环嵌套

> 回溯算法可以解决的问题

除了以下这些问题，各种算法中也会用到递归，如快排，二分查找，分治算法等

+ 迷宫问题
+ 八皇后问题
+ 汉诺塔问题
+ 阶乘问题
+ 迷宫问题
+ 球和篮子的问题

这里列出迷宫问题和八皇后问题

**迷宫问题**

```java
import java.util.Arrays;

public class Maze {
    public static void main(String[] args) {
        //创建一个二维数组模拟迷宫
        //1代表墙，2代表轨迹，0代表可以进入
        int[][] map = new int[8][7];
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }
        for (int j = 1; j < 7; j++) {
            map[j][0] = 1;
            map[j][6] = 1;
        }
        for (int res[] :map){
            System.out.println(Arrays.toString(res)+" ");
        }
        //设置挡板, 1 表示
        map[3][1] = 1;
        map[3][2] = 1;
        System.out.println("===========");
        setWay(map, 1, 1);
		//展示走完后的路径，用数字2表示
       	for (int res[] :map){
           System.out.println(Arrays.toString(res)+" ");
       }
    }

    //使用递归回溯给小球找路
    //1. map 表示地图
    //2. i,j 表示从地图的哪个位置开始出发 (1,1)
    //3. 如果小球能到 map[6][5] 位置，则说明通路找到.
    //4. 约定： 当 map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通
    //5. 在走迷宫时，需要确定一个策略(方法) 下->右->上->左 , 如果该点走不通，再回溯

    /**
     * @param map 表示地图
     * @param i   从哪个位置开始找
     * @param j
     * @return 如果找到通路，就返回 true, 否则返回 false
     */
    public static boolean setWay(int[][] map, int i, int j) {
        if (map[6][5] == 2) { // 通路已经找到 ok
            return true;
        } else {
            if (map[i][j] == 0) { //如果当前这个点还没有走过
                //按照策略 下->右->上->左 走
                map[i][j] = 2; // 假定该点是可以走通.
                if (setWay(map, i + 1, j)) {//向下走
                    return true;
                } else if (setWay(map, i, j + 1)) { //向右走
                    return true;
                } else if (setWay(map, i - 1, j)) { //向上
                    return true;
                } else if (setWay(map, i, j - 1)) { // 向左走
                    return true;
                } else {
                    //说明该点是走不通，是死路
                    map[i][j] = 3;
                    return false;
                }
            } else { // 如果 map[i][j] != 0 , 可能是 1， 2， 3
                return false;
            }
        }
    }
}
```

**八皇后问题**

> 国际象棋中的皇后，可以横向、纵向、斜向移动。如何在一个8X8的棋盘上放置8个皇后，使得**任意两个皇后都不在同一条横线、竖线、斜线方向上**
>
> 解决八皇后问题，可以分为两个层面：
>
> 1.**找出第一种正确摆放方式**，也就是深度优先遍历（DFS）
>
> 2.**找出全部的正确摆放方式**，也就是广度优先遍历（BFS)

先简单提一下DFS和BFS

> BFS 常用于找单一的最短路线，它的特点是 "搜到就是最优解"，而 DFS 用于找所有解的问题，它的空间效率高，而且找到的不一定是最优解，必须记录并完成整个搜索，故一般情况下，深搜需要非常高效的剪枝（剪枝的概念请百度）

Java代码输出全部的摆放方式，以及对运行效率的分析

:eight_spoked_asterisk:-广度优先遍历

代码实现

使用深度优先遍历邻接矩阵

```

```

### BFS

### 最短路径算法

> 单源点最短路径————Dijkstra算法
>
> 所有顶点间的最短路径————Floyd算法

#### Dijkstra算法

> 思路：按路径长度递增次序产生最短路径
>
> 代码构思：
>
> 1、假设给定一个顶点集合V,求到达某个顶点的最短路径
>
> 
>
> 2、定义一个boolean judge[V.length]来确定V中该顶点是否已经确定最短路径
>
> 
>
> 3、定义一个int dist[V.length]来初始化并动态更新源点到其他顶点的距离
>
> 4、
>
> ```java
> while(!judge[i]){//该点还未确定最短路径
>     min = Integer.MAX_VALUE;
>             for (从源点遍历整个集合V)  //循环找到从源点出发最近的距离
>                 if (!judge[i] && dist[i] < min) {  
>                     //交换两数与下标
>                 }
>     //可以确定离源点距离最近的一个点，V(源点) -- V(minIndex)
>     bj[minIndex] = true;
> 
>     //用这个点当中间点，找到 V(源点) -- V(minIndex) -- V(和V(minIdx)有边的点)，再一次更新最短路径
>             for () {//遍历和V（minIndex）有边的点
>                 if (dist[i] == C)//如果该点到源点没有直达边，更新距离下··
>                     dist[i] = dist[minIdx] + map[minIdx][i];
>                 //两边之和小于直达边，更新顶点到该边的距离
>                 else if (dis[minIdx] + map[minIdx][i] < dis[i])
>                     //（V(0),minIndex) + (minIndex,V（k))   < (V(0),V(k))
>                     dist[i] = dist[minIdx] + map[minIdx][i];
>             }
> }
> ```
>
> 



> 步骤

1. 先确定从源点V(0)到各终点V(k)的直达路径，即通过一条边就可以到达的路径

2. 从这个路径找到一条长度最短的路径 （V(0),u)   **代码34-40行**

3. 对其余路径做出调整 **代码44-51行**

   若图中存在边 (u,V（k) ，且`（V(0),u) + (u,V（k) < (V(0),V(k))`,则以路径（V(0),u,V(k)）代替(V(0),V(k))

有点贪心的感觉，每次都寻找当前最优解

> 代码实现

```java
public class Main {
    //答案：10266837
    final static int C = 999999999;//定义该点无直达
    public static void main(String[] args) {
        //初始化邻接矩阵
        int[][] map = new int[2050][2050];
        //首先初始化为最大值
        for (int[] temp : map) {
            for (int i = 0; i < temp.length; i++) {
                temp[i] = C;
            }
        }
        //按照题意赋值
        for (int i = 1; i <= 2021; i++) {
            for (int j = i; j <= i + 21; j++) {
                //对a,b相差21以内的边赋权
                map[i][j] = lcm(i, j);
            }
        }
        //Dijkstra:按路径长度递增次序产生最短路径
        /*
        V:代表所有顶点
        bj:代表顶点是否已确定最短路径
        */
        boolean bj[] = new boolean[2050];//用来标记该点是否找到最短路径
        int dis[] = new int[2050];//存储源点到其他顶点的初始路径
        for (int i = 1; i <= 2021; i++)
            dis[i] = map[1][i];//先赋值为直达路径
        int min, minIdx = 0;
        //没执行一次while循环，确定到一个点的最短路径
        while (!bj[2021]) {//如果2021点的最短路径还没求到就一直循环
            min = Integer.MAX_VALUE;
            //每次找到从源点出发最近的距离
            for (int i = 2; i <= 2021; i++) {
                if (!bj[i] && dis[i] < min) {
                    //交换
                    min = dis[i];
                    minIdx = i;
                }
            }
            bj[minIdx] = true;//循环一圈以后，可以确定一个最短的点，然后进行下一次循环，直到bj[2021]==true

            //从最近的这个点当中间点，找到 V(0) -- V(minIdx) -- V(和V(minIdx)有直连的点)，再一次更新最短路径
            for (int i = minIdx + 1; i <= minIdx + 21; i++) {
                //如果该点到源点没有边
                if (dis[i] == C)
                    dis[i] = dis[minIdx] + map[minIdx][i];
                //两边之和小于直达边，更新距离
                else if (dis[minIdx] + map[minIdx][i] < dis[i])
                    dis[i] = dis[minIdx] + map[minIdx][i];
            }
        }
        System.out.println(dis[2021]);
    }

    //求最大公约数
    public static int gcd(int x, int y) {
        if (y == 0)
            return x;
        return gcd(y, x % y);
    }
    public static int lcm(int x, int y) {//最小公倍数
        return x * y / gcd(x, y);
    }

}
```



#### Floyd算法













## 数论

### 分解质因数

```java
	for (long i = 1; i * i <= n; i++) {//求所有公因子的方法 很大程度上提高了效率
            if (n % i == 0) {
                list.add(i);
                if (i != n / i) {
                    list.add(n / i);
                }
            }
        }
```



### 筛素数

```javascript
if（num%4==0&&num%100!=0||num%400==0)
```



### 回文数



### 最大公约数与最小公倍数

欧几里德算法又称辗转相除法，用于计算两个整数a,b的最大公约数`GCD(greatest common divisor)`。其计算原理依赖于下面的定理：

定理：gcd(a,b) = gcd(b,a mod b)

```java
int Gcd(int a, int b)
{
    if(b == 0)
        return a;
    return Gcd(b, a % b);
}
```

> 利用最大公约数求最小公倍数

两个数的乘积等于这两个数的最大公约数与最小公倍数的乘积。假设有两个数是a、b，它们的最大公约数是p，最小公倍数是q。那么存在这样的关系式：ab=pq













