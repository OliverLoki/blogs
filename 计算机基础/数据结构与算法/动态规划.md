动态规划相信大家都知道，动态规划算法也是新手在刚接触算法设计时很苦恼的问题，有时候觉得难以理解，但是真正理解之后，就会觉得动态规划其实并没有想象中那么难。网上也有很多关于讲解动态规划的文章，大多都是叙述概念，讲解原理，让人觉得晦涩难懂，即使一时间看懂了，发现当自己做题的时候又会觉得无所适从。我觉得，理解算法最重要的还是在于练习，只有通过自己练习，才可以更快地提升。话不多说，接下来，下面我就通过一个例子来一步一步讲解动态规划是怎样使用的，只有知道怎样使用，才能更好地理解，而不是一味地对概念和原理进行反复琢磨

### 算法描述

> 定义

**动态规划**（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题动态规划和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

这样的述太过官方，那到底该如何理解动态规划呢？
+ 阶段之间可以进行转移，这叫做动态
+ 达到一个可行解(目标阶段) 需要不断地转移，那如何转移才能达到最优解？这叫规划

动态规划，无非就是利用**历史记录**，来避免我们的重复计算。而这些**历史记录**，我们得需要一些**变量**来保存，一般是用**一维数组**或者**二维数组**来保存。下面我们先来讲下做动态规划题很重要的三要素和三个步骤

> 三要素

动态规划问题的进阶一般形式就是求最值，也常被用来优化递归算法。比如说让你求`最长递增子序列`呀，`最小编辑距离`呀等等

既然是要求最值，核心问题是什么呢？**求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。

这么一说，好像动态规划很简单？

但是，动态规划的穷举有点特别，因为这类问题**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来记录数据，优化穷举过程，避免不必要的计算。

而且，动态规划问题一定会**具备「最优子结构」**，才能通过子问题的最值得到原问题的最值。

另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的**「状态转移方程」**才能正确地穷举。

**以上提到的:tangerine:`重叠子问题`、`最优子结构`、`状态转移方程`就是动态规划三要素**

理解这些名词最好的方法就是在题目中去感受它们，刷题越多，对动态规划也就有了一定的感觉

### 入门动态规划

> 三个步骤

1. **第一步骤**：定义**数组元素的含义**，上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？
2. **第二步骤**：找出**数组元素之间的关系式**，我觉得动态规划，还是有一点类似于我们高中学习时的**归纳法**的，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2]…..dp[1]，来推出 dp[n] 的，也就是可以利用**历史数据**来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。而这一步，也是最难的一步，后面我会讲几种类型的题来说。
3. **第三步骤**：找出**初始值**。学过**数学归纳法**的都知道，虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值，而这，就是**所谓的初始值**（Base case）

由了**初始值**，并且有了**数组元素之间的关系式**，那么我们就可以得到 dp[n] 的值了，而 dp[n] 的含义是由你来定义的，你想**求什么，就定义它是什么**，这样，这道题也就解出来了。



之后我们进入刷题环节



从青蛙跳楼梯的部分开始入门吧

> 问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法

首先如果只有1个台阶，那青蛙只有一种跳法；如果有两个台阶，青蛙有两种跳法：一个台阶一个台阶跳；一次跳两个台阶；如果有n（n > 2）个台阶，假设用函数f（n）表示总共跳的方法数，这时青蛙在第一次有两种选择：选择跳一个台阶，则剩下n-1个台阶故剩下的台阶有f（n-1）种跳法；选择跳两个台阶，则剩下n-2个台阶故剩下的台阶有f（n-2）种跳法。

从后往前递推，完成n级台阶的最后一次动作可能是跳1级，可能是跳2级，故f（n）= f（n-1） + f（n-2）；n=1时f（n） = 1；n = 2时f（n）= 2；于是可以看到这个题目是明显的递归

```java
 	//基于递归实现
public long jumpStep(int n){
	if (n == 0 || n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 2] + dp[i - 1];
        }
        return dp[n];  
}
```

然后我们用动态规划来理解这道题



 **(1)、定义数组元素的含义**

按我上面的步骤说的，首先我们来定义 dp[i] 的含义，我们的问题是要求青蛙跳上 n 级的台阶总共由多少种跳法，那我们就定义 dp[i] 的含义为：**跳上一个 i 级的台阶总共有 dp[i] 种跳法**。这样，如果我们能够算出 dp[n]，不就是我们要求的答案吗？所以第一步定义完成

**（2）、找出数组元素间的关系式**

我们的目的是要求 dp[n]，动态规划的题，如你们经常听说的那样，就是把一个**规模**比较大的问题分成几个**规模**比较小的问题，然后由小的问题推导出大的问题。也就是说，dp[n] 的规模为 n，比它规模小的是 n-1, n-2, n-3…. 也就是说，dp[n] 一定会和 dp[n-1], dp[n-2]….存在某种关系的。我们要找出他们的关系。

那么问题来了，怎么找？

这个怎么找，**是最核心最难的一个**，我们必须回到问题本身来了，来寻找他们的关系式，dp[n] 究竟会等于什么呢？

```
设跳上 n 级台阶有 dp(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶

当为 1 级台阶： 剩 n−1 个台阶，此情况共有 f(n−1) 种跳法；
当为 2 级台阶： 剩 n−2 个台阶，此情况共有 f(n−2) 种跳法。
```

由于我们是要算所有可能的跳法的，所以有 dp[n] = dp[n-1] + dp[n-2]



**（3）、找出初始条件**

当 n = 1 时，dp[1] = dp[0] + dp[-1]，而我们是数组是不允许下标为负数的，所以对于 dp[1]，我们必须要**直接给出它的数值**，相当于初始值，显然，dp[1] = 1。一样，dp[0] = 0.（因为 0 个台阶，那肯定是 0 种跳法了）。于是得出初始值：

dp[0] = 0



三个步骤都做出来了，那么我们就来写代码吧

```java
int numWays( int n ){
    	if (n == 0 || n == 1) return 1;
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = (dp[i - 2] + dp[i - 1]);
        }
        return dp[n];
}
```

到这里，我们写出了第一个动态规划代码。但是我们为什么要这样做呢？那我们来看一下动态规划是怎样优化递归函数的叭，这里会涉及到**重叠子问题**这个概念



对了，动态规划也是可以优化的哦，以后有机会我会记录这方面的内容



####  斐波那契数

它并不是动态规划问题，但是可以帮助理解 重叠子问题 这个概念

> 题目：求斐波那契数
>
> **斐波那契数列**指的是这样一个数列：1，1，2，3，5，8，13，21，34，55，89...
>
> 这个数列从第3项开始，每一项都等于前两项之和

重叠子问题：用来求解原问题的递归算法反复地解同样的子问题，而不是总是在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的

```java
 	public static int fibonacci(int n){
        if (n== 1||n==2)
            return 1;
        return fibonacci(n-1)+fibonacci(n-2);
    }
```

画出递归树，可以看到如果要求 fibonacci(20), 那么`fabnacci(18)`会涉及到重复计算，存在大量重复计算，比如`fabnacci(18)`被计算了两次，而且你可以看到，以`fabnacci(18)`为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止`fabnacci(18)`这一个节点被重复计算，所以这个算法及其低效。

![image-20220316140536074](https://img-blog.csdnimg.cn/img_convert/c174fee9ca43a87b1d3017119c7fcfc7.png)



明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了

> 演进一：**带备忘录的递归解法**

```java
	//带备忘录的递归 
	//时间复杂度O(n)
    public static int fib(int n){
        int[] memory = new int[n+1];
        return fib(n,memory);
    }
    public static int fib(int n,int[] memoary) {
        //base case
        if (n == 1 || n == 2) return 1;
        if (memoary[n]!=0) return memoary[n];
        memoary[n] = fib(n-1,memoary)+fib(n-2,memoary); 	
        return memoary[n];
    }
```

本算法不存在冗余计算，子问题就是`fib(1)`,`fib(2)`,`fib(3)`…`fib(20)`，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。

至此，带备忘录的递归解法的效率已经和迭代的动态规划一样了。实际上，这种解法和迭代的动态规划思想已经差不多，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。

> 优化二：**dp 数组的迭代解法**--引出状态转移方程

有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算

```java
	//时间复杂度O(n)
    public static int fib2(int n) {
        int[] dp = new int[n + 1];//DP table
        dp[1] = dp[2] = 1;//base case
        for (int i = 3; i <= n; i++)
            dp[i] = dp[i - 1] + dp[i - 2];//状态转移方程
        return dp[n];
```

在这里引出`「状态转移方程」`这个名词，实际上就是描述问题结构的数学形式

我把它理解为一个分段函数，例如对斐波那契数这个例子

![image-20220316151733235](https://img-blog.csdnimg.cn/img_convert/774a8e397eb76f89231d84e261c79fdd.png)



希望读者可以通过这个例子对重叠子问题和状态转移方程有一个基本的理解，但是动态规划的另一个重要特性「最优子结构」，并没有在这个例子中涉及到，因为斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在演示算法设计螺旋上升的过程。



我们来看下一个问题

#### 背包问题

+ 01背包：每种物品不可重复
+ 完全背包：每种物品可以无限使用

> **0—1背包**
>
> 给你一个可装载重量为`W`的背包和`N`个物品，每个物品有重量和价值两个属性。其中第`i`个物品的重量为`wt[i]`，价值为`val[i]`，现在让你用这个背包装物品，最多能装的价值是多少

**这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。**这也许就是 0-1 背包这个名词的来历。



我们分别理解状态和转移，然后按照下面的步骤来做题

1. 第一步要明确两点，「状态」和「选择」

   背包的容量/所有物品

2. 第二步要明确`dp`数组的定义--两个状态，考虑二维dp

   `dp[i][w]`的定义：对于前`i`个物品，当前背包的容量为`w`，这种情况下最大价值是`dp[i][w]`

   **根据这个定义，我们想求的最终答案就是**`dp[N][W]`

   **base case 就是`dp[0][..] = dp[..][0] = 0`**，因为没有物品或者背包没有空间的时候，最大价值就是 0。

3. 第三步，根据「选择」，思考状态转移的逻辑

   

然后给出一个动态规划思考的模板思路

```java
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
```

按照这个思路理一下框架

```java
int dp[N+1][W+1]
dp[0][..] = 0
dp[..][0] = 0

for i in [1..N]:
    for w in [1..W]:
        dp[i][w] = max(
            把物品 i 装进背包,
            不把物品 i 装进背包
        )
return dp[N][W]
```

Java代码描述

```java
/**
     * @param W 背包容量
     * @param N 物品数量
     * @param wt Wt[i]代表第i个物品的重量
     * @param val val[i]代表第i个物品的价值
     * @return
     */
    public static int knapsack(int W, int N, int[] wt,int[] val) {
        //base case 已初始化
        //dp[i][w]表示对于前i个物品，当前背包的容量为w，这种情况下可以装的最大价值是dp[i][w]
        int[][] dp = new int[N+1][W+1];
        for (int i = 1; i <= N; i++) {
            for (int w = 1; w <= W; w++) {
                if (w - wt[i-1] < 0) {
                    // 当前背包容量装不下，只能选择不装入背包
                    dp[i][w] = dp[i - 1][w];
                } else {
                    // 装入或者不装入背包，择优
                    dp[i][w] = Math.max(dp[i - 1][w - wt[i-1]] + val[i-1],
                            dp[i - 1][w]);
                }
            }
        }
        return dp[N][W];
    }
```

> 完全背包
>
> 有一个背包，最大容量为`amount`，有一系列物品`coins`，每个物品的重量为`coins[i]`，**每个物品的数量无限**。请问有多少种方法，能够把背包恰好装满

无非就是状态转移方程有一点变化而已

以力扣518题为例

https://leetcode-cn.com/problems/coin-change-2/

```java
int change(int amount, int[] coins) {
    int n = coins.length;
    int[][] dp = amount int[n + 1][amount + 1];
    // base case
    for (int i = 0; i <= n; i++) 
        dp[i][0] = 1;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= amount; j++)
            if (j - coins[i-1] >= 0)
                dp[i][j] = dp[i - 1][j] 
                         + dp[i][j - coins[i-1]];
            else 
                dp[i][j] = dp[i - 1][j];
    }
    return dp[n][amount];
}
```

来看下一个问题

#### 凑零钱问题

力扣[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

> 题目：给你`k`种面值的硬币，面值分别为`c1, c2 ... ck`，每种硬币的数量无限，再给一个总金额`amount`，问你**最少**需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：
>
> ```java
> // coins 中是可选硬币面值，amount 是目标金额
> int coinChange(int[] coins, int amount);
> ```

通过这道题理解最优子结构这个概念为什么说它符合最优子结构呢？比如你想求`amount = 11`时的最少硬币数（原问题），如果你知道凑出`amount = 10`的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案



既然确定了这是一个动规问题

> **明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。**

我们回到凑零钱问题

1. 找到状态： 目标金额amount

2. 确定dp函数的定义：函数 dp(n)表示，当前的目标金额是`n`，至少需要`dp(n)`个硬币凑出该金额

3. 确定「选择」并择优： 也就是对于每个状态，可以做出什么选择改变当前状态。

   具体到这个问题，无论当的目标金额是多少，选择就是从面额列表`coins`中选择一个硬币，然后目标金额就会减少、

自底向上**使用 dp table 来消除重叠子问题**，dp[i]表示，当目标金额为i时至少需要i枚硬币

```java
   public int coinChange(int[] coins, int amount) {
        int max = amount + 1;
       	//定义dp数组大小为amount+1,初始值也为amount+1,
       //为什么dp数组初始化为amount + 1呢，因为凑成amount金额的硬币数最多只可能等于amount（全用 1 元面值的硬币），所以初始化为amount + 1就相当于初始化为正无穷，便于后续取最小值
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, max);
        dp[0] = 0;//base case
        for (int i = 1; i <= amount; i++) {//amount为金额
            for (int j = 0; j < coins.length; j++) {             
                if (coins[j] <= i) {//如果可以用硬币表示
                   	//找到上一个数+x个硬币数量的最小值
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
       	//所需要金币数量大于金额，说明无解，返回-1
        return dp[amount] > amount ? -1 : dp[amount];
    }
```

### 进阶动态规划

> 求最大连续和问题

#### 最大连续和

[剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

**问题描述**

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

示例1:

输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

> 思路：可以用前缀和来做，这里我们说动态规划
>
> 难点在于对状态转移方程的定义：
>
> 用 dp[i] 代表以第 *i* 个数结尾的「连续子数组的最大和」

> 动态规划--- 最佳实践 时间复杂度 O(n)

设滚动变量 dp ，代表以元素 nums[i] 为结尾的连续子数组最大和

```java
class Solution {
   public int maxSubArray(int[] nums) {
        int pre = 0;
        int dp = nums[0];//滚动变量
        for (int x : nums) {
            pre = Math.max(x + pre, x);
            dp = Math.max(dp, pre);
        }
        return dp;
    }
}
```

#### 最长递增子序列

> 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
>
> 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
>
>
> 示例 1：
>
> 输入：nums = [10,9,2,5,3,7,101,18]
> 输出：4
> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

> 思路：
>
> 利用Hash表，key存储num[i],value存储num[i]对应的右边界
>
> 初始化哈希表，key和value都等于num[i]
>
> 遍历Hash表，动态更新每个数的最右边界，动态更新最大最右边界

```java
 //key存值，value保存右边界
        public int longestConsecutive(int[] nums) {
            HashMap<Integer, Integer> map = new HashMap<>();
            int ans = 0;
            for (int num : nums)
                map.put(num, num);//初始化
            //更新边界
            for (int num : nums) {
                if (!map.containsKey(num - 1)) {//如果不包含上一个值，那么开始更新这个值
                    int right = map.get(num);
                    while (map.containsKey(right + 1)) {
                        right = map.get(right + 1);
                    }
                    //更新边界
                    map.put(num, right);
                    ans = Math.max(ans, right - num + 1);
                }
            }
            return ans;
        }
    }
```

#### 最长公共子序列

> 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。
>
> 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
>
> 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
> 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。
>
> 示例 1：
>
> 输入：text1 = "abcde", text2 = "ace" 
> 输出：3  
> 解释：最长公共子序列是 "ace" ，它的长度为 3 

```java
// 定义：将 s1[i..] 和 s2[j..] 删除成相同字符串，
// 最小的 ASCII 码之和为 dp(s1, i, s2, j)。
int dp(String s1, int i, String s2, int j) {
    int res = 0;
    // base case
    if (i == s1.length()) {
        // 如果 s1 到头了，那么 s2 剩下的都得删除
        for (; j < s2.length(); j++)
            res += s2.charAt(j);
        return res;
    }
    if (j == s2.length()) {
        // 如果 s2 到头了，那么 s1 剩下的都得删除
        for (; i < s1.length(); i++)
            res += s1.charAt(i);
        return res;
    }

    if (memo[i][j] != -1) {
        return memo[i][j];
    }

    if (s1.charAt(i) == s2.charAt(j)) {
        // s1[i] 和 s2[j] 都是在 lcs 中的，不用删除
        memo[i][j] = dp(s1, i + 1, s2, j + 1);
    } else {
        // s1[i] 和 s2[j] 至少有一个不在 lcs 中，删一个
        memo[i][j] = Math.min(
            s1.charAt(i) + dp(s1, i + 1, s2, j),
            s2.charAt(j) + dp(s1, i, s2, j + 1)
        );
    }
    return memo[i][j];
}
```