





# 第一章：了解Web及网络基础

## 1、为知识共享而规划Web

+ CERN（欧洲核子研究组织）的 `Tim Berners-Lee` 博士提出了一种能让远隔两地的研究者们共享知识的设想

+ 三项万维网（`World Wide Web`）技术
  + HTML: 把 SGML（标准通用标记语言）作为页面的文本标记语言
  + HTTP: 文档传递协议
  + URL: 指定文档所在地址
+ WWW 这一名称，是 Web 浏览器当年用来浏览超文本的客户端应用程序时的名称。现在则用来表示这一系列的集合，也可简称为 Web

## 2、名词解释：协议

计算机与网络设备要相互通信，双方就必须基于相同的方法。比如如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）



## 3、计算机网络五层架构常用协议

+ 应用层：

  + HTTP
  + DNS

+ 运输层：

  + TCP（提供可靠的字节流传输服务）
  + UDP:

+ 网络层：

  + IP
  + ARP
  + ICMP
  + IGMP

+ 数据链路层：1、封装成帧 2、透明传输 3、差错检测

  

+ 物理层：这一层更偏向于物理和电气特性

## 4、利用 TCP/IP 协议族进行网络通信示意图

> 用 HTTP 举例来说明，首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求

1. 为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层
2. 在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了
3. 接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求



**图示：通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走**

![image-20220518225745087](https://s2.loli.net/2022/05/18/k7MxQ84mE1rngPu.png)



## 5、与HTTP紧密相关的协议：TP、TCP、DNS

图示：

![image-20220519143229865](https://s2.loli.net/2022/05/19/9kXTlMV6KmPDudf.png)



## 6、URI和URL

+ URL - Uniform Resource Locator - 统一资源定位符

+ URI - Uniform Resource Identifier - 统一资源标识符





# 第二章：简单的HTTP协议

## 1、HTTP是基于客户端和服务端之间的通信

+ 在两台计算机之间使用 HTTP 协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端

+ 有时候，按实际情况，两台计算机作为客户端和服务器端的角色有可能会互换。但就仅从一条通信路线来说，服务器端和客户端的角色是确定的，而用 HTTP 协议能够明确区分哪端是客户端，哪端是服务器端



## 2、通过请求和响应的交换达成通信

HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应



**客户端发送请求报文**

![image-20220519150921521](https://s2.loli.net/2022/05/19/81vxqyCA7zP9mtX.png)



**服务端收到客户端请求报文后发送响应报文**

![image-20220519150941075](https://s2.loli.net/2022/05/19/L3SWsqgrPaGEB9U.png)

## 3、HTTP是无状态协议

+ 为了更快地处理大量事务，确保协议的可伸缩性，**HTTP协议对于发送过的请求或响应都不做持久化处理**

![image-20220519151224585](https://s2.loli.net/2022/05/19/Wn6mObjaXLlhGuz.png)



+ `HTTP/1.1`为了实现保持状态功能，引入了 `Cookie` 技术

## 4、告知服务器意图的HTTP方法

![image-20220519151924399](https://s2.loli.net/2022/05/19/ySiHxZkPdYamjJK.png)



## 5、HTTP持久连接

+ HTTP/1.1之后默认连接都是持久连接

+ 只要任意一端没有明确提出断开连接，则保持 TCP 连接状态

+ **持久连接旨在建立 1 次 TCP 连接后进行多次请求和响应的交互**

![image-20220519173429528](https://s2.loli.net/2022/05/19/bQk3wAdEGMVcLu4.png)



> **持久连接使得多数请求以管线化（pipelining）方式发送成为可能**

从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了



![image-20220519180702646](https://s2.loli.net/2022/05/19/L8vEcwB1JSYpD7W.png)

## 6、使用Cookie实现会话保持

+ Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态

+ Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。
+ 服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息



**HTTP 请求报文和响应报文的内容如下**

> 请求报文

首部字段内没有Cookie的相关信息

```
GET /reader/ HTTP/1.1
Host: hackr.jp
```

> 响应报文（服务器端生成Cookie信息）

```
HTTP/1.1 200 OK
Date: Thu, 12 Jul 2012 07:12:20 GMT
Server: Apache
＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,
10-Oct-12 07:12:20 GMT＞
Content-Type: text/plain; charset=UTF-8
```

> 请求报文（自动发送保存着的 Cookie 信息）

```
GET /image/ HTTP/1.1
Host: hackr.jp
Cookie: sid=1342077140226724
```







# 第三章：HTTP报文内的HTTP信息

## 1、请求报文与响应报文的结构

![image-20220519181911236](https://s2.loli.net/2022/05/19/ug6JtFLXrTdSA31.png)



> **请求报文和响应报文的实例**

+ 请求行: 包含用于请求的方法，请求 URI 和 HTTP 版本



![image-20220519182228068](https://s2.loli.net/2022/05/19/3SxtonXqiyfuwEL.png)



+ 状态行: 包含表明响应结果的状态码，原因短语和 HTTP 版本

![image-20220519182239999](https://s2.loli.net/2022/05/19/5YtGiajNbPI4ZS8.png)



+ 首部字段: 包含表示请求和响应的各种条件和属性的各类首部

  一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）

## 2、编码提升传输速率

HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的CPU 等资源



## 3、内容协商返回最合适的内容

![image-20220519225544108](https://s2.loli.net/2022/05/19/CilKjZOf6dAua1r.png)

内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。



**包含在请求报文中的某些首部字段（如下）就是判断的基准。这些首部字段的详细说明请参考下一章。**

+ Accept
+ Accept-Charset
+ Accept-Encoding
+ Accept-Language
+ Content-Language





# 第四章：返回结果的HTTP状态码

> HTTP状态码负责表示客户端HTTP请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。让我们通过本章的学习，好好了解一下状态码的工作机制



> **仅 记 录 在 RFC2616 上 的 HTTP 状 态 码 就 达 40 种， 若 再 加 上WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）（RFC4918、5842）和附加 HTTP 状态码**
> **（RFC6585）等扩展，数量就达 60 余种。别看种类繁多，实际上经常使用的大概只有 14 种。接下来，我们就介绍一下这些具有代表性的 14 个状态码**

## 1、状态码的类别

![image-20220519183805035](https://s2.loli.net/2022/05/19/dyOsxQwWEZ7Ggzc.png)



## 2、2XX -> 成功

+ `200 OK`：表示从客户端发来的请求在服务器端被正常处理了
+ `204 No Content`：请求处理成功，但没有资源可返回
+ `206 Partial Content`：该状态码表示客户端进行了范围请求，而服务器成功执行了这部分
  的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容

## 3、3XX -> 重定向

+ 301 永久性重定向

+ 302 临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问
+ 303 该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源
+ 304 该状态码表示客户端发送附带条件的请求A 时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系
+ 307 临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守

## 4、4XX -> 客户端错误

+ `400 Bad Request`该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码

+ `401 Unauthorized`认证不通过
+ `403 Forbidden`该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因
+ `404 Not Found`该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用



## 5、5XX -> 服务端错误

+ `500 Internal Server Error`该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障
+ `503 Service Unavailable` 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求



# 第五章：与HTTP协作的Web服务器

> **一台Web服务器可搭建多个独立域名的Web网站，也可作为通信路径上的中转服务器提升传输效率**

## 1、常见的Web服务器

+ Tomcat
+ [Nginx](blog.csdn.net/Night__breeze/article/details/124457586)
+ IIS
+ Apache

**Web服务器工作原理**

![image-20220519212706372](https://s2.loli.net/2022/05/19/ZclMzm9hCNb8EQV.png)







## 2、通信数据转发程序：代理、网关、隧道

> **代理**

![image-20220519225751677](https://s2.loli.net/2022/05/19/HuUimt93e4D5AZ7.png)

> 网关

**![image-20220519225730956](https://s2.loli.net/2022/05/19/1Mrj5S6kFpZEKxi.png)**



> 隧道

![image-20220519225808013](https://s2.loli.net/2022/05/19/LfOqgE8cQd3SrZK.png)





# 第六章：HTTP首部

> HTTP协议的请求和响应报文中必定包含HTTP首部，只是我们平时在使用Web的过程中感受不到它。本章我们一起来学习HTTP首部的结构，以及首部中各字段的用法







# 第七章：确保Web安全的HTTPS

> **在HTTP协议中有可能存在信息窃听或身份伪装等安全问题。使用HTTPS通信机制可以有效地防止这些问题。本章我们就了解一**
> **下HTTPS**

## 1、HTTP的缺点

> 1）通信使用明文（不加密），内容可能会被窃听

+ 窃听相同段上的通信并非难事。只需要收集在互联网上流动的数据包（帧）就行了。对于收集来的数据包的解析工作，可交给那些抓包（Packet Capture）或嗅探器（Sniffer）工具

**图为使用Wireshark工具进行抓包**

![image-20220519214234098](https://s2.loli.net/2022/05/19/RvgJW8FcCaTnb2K.png)

**在目前大家正在研究的如何防止窃听保护信息的几种对策中，最为普及的就是加密技术**

1. 一种方式就是将通信加密。HTTP 协议中没有加密机制，但可以通过和 `SSL`（`Secure Socket Layer`，安全套接层）或 `TLS`（`Transport LayerSecurity`，安全层传输协议）的组合使用，加密 HTTP 的通信内容。用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP通信了。**与 `SSL` 组合使用的 `HTTP` 被称为 `HTTPS`**
2. 还有一种将参与通信的内容本身加密的方式。由于 HTTP 协议中没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把 HTTP 报文里所含的内容进行加密处理，由于该方式不同于 SSL 或 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险

> 2）HTTP 协议中的请求和响应不会对通信方进行确认，因此有可能遭遇伪装

任何人都可以发送请求

![image-20220519215022511](https://s2.loli.net/2022/05/19/PNV2XdAxskQTiep.png)

+ 即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS攻击（`Denial of Service`，拒绝服务攻击）
+ 无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存着重要的信息，只想发给特定用户通信的权限
+ 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器
+ 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端

**虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL 则可以。SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方**

> 无法证明报文的完整性，所以有可能已遭篡改

![image-20220519221246716](https://s2.loli.net/2022/05/19/uqJ32pt4T9enYo6.png)



比如，从某个 Web 网站上下载内容，是无法确定客户端下载的文件和服务器上存放的文件是否前后一致的。文件内容在传输途中可能已经被篡改为其他的内容。即使内容真的已改变，作为接收方的客户端也是觉察不到的。
像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack，MITM）

![image-20220519221451392](https://s2.loli.net/2022/05/19/yKutYLEDa23X5jz.png)



> **如何防止被篡改**————》 MD5文件校验

## 2、SSL协议：证书 + 公开密钥加密技术

**SSL 是当今世界上应用最为广泛的网络安全技术**

> 加密技术

SSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式

![image-20220519230433198](https://s2.loli.net/2022/05/19/XgAKWuiM9E7FevP.png)

> 证书——证明公开密钥正确性

+ 要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。证书价格可能会根据不同的认证机构略有不同

+ 证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图

![image-20220519221108259](https://s2.loli.net/2022/05/19/XUWxlODEcjfw5JI.png)



通过使用证书，以证明通信方就是意料中的服务器。这对使用者个人来讲，也减少了个人信息泄露的危险性

另外，客户端持有证书即可完成个人身份的确认，也可用于对 Web网站的认证环节

> SSL速度慢

+ SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗 CPU及内存等资源，导致处理速度变慢

+ 针对速度变慢这一问题，并没有根本性的解决方案，我们会使用SSL 加速器这种（专用服务器）硬件来改善该问题。该硬件为 SSL 通信专用硬件，相对软件来讲，能够提高数倍 SSL 的计算速度。仅在 SSL处理时发挥 SSL 加速器的功效，以分担负载

## 3、HTTPS是什么

> **HTTPS 使 用 SSL（Secure Socket Layer） 和 TLS（Transport LayerSecurity）这两个协议，把添加了加密及认证机制的 HTTP 称为 HTTPS**

+ 通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP

## 4、HTTPS采用混合加密机制

![image-20220519230332050](D:\桌面\P_picture_cahe\image-20220519230332050.png)



## 5、HTTPS的安全通信机制

仅使用服务器端的公开密钥证书（服务器证书）建立 HTTPS 通信的整个过程

![image-20220519230731086](https://s2.loli.net/2022/05/19/W8uGjmMyB6D3PTr.png)





# 第八章：确定访问用户身份的认证

1. BASIC认证：不够便捷灵活,且达不到多数 Web 网站期望的安全性等级,因此它并不常用
2. DIGEST认证：查验首部字段 `Authorization`，这个字段里面可能是一个Token，[可以看这篇文章](https://blog.csdn.net/Night__breeze/article/details/124016688)
3. SSL认证
4. 基于表单认证

> SSL 客户端认证

步骤 1: 接收到需要认证资源的请求,服务器会发送 Certificate Request 报文,要求客户端提供客户端证书。

步骤 2: 用户选择将发送的客户端证书后,客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。

步骤 3: 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥,然后开始 HTTPS 加密通信



> 基于表单认证

认证多半为基于表单认证

基于表单认证的标准规范尚未有定论,一般会使用 Cookie 来管理 Session(会话)

步骤 1: 客户端把用户 ID 和密码等登录信息放入报文的实体部分,通常是以 POST 方法把请求发送给服务器

步骤 2: 服务器会发放用以识别用户的 Session ID。会在首部字段 Set-Cookie 内写入 Session ID

步骤 3: 客户端接收到从服务器端发来的 Session ID 后,会将其作为 Cookie 保存在本地

下次向服务器发 送请求时, 浏览器会自动发送 Cookie, 所以 Session ID 也随之发送到服务器



# 第九章：基于HTTP的功能追加协议

## 1、HTTP/2.0七项技术探讨

+ HTTP/2.0 的目标是改善用户在使用 Web 时的速度体验

+ 在 2014 年 11 月实现标准化

![image-20220519232255961](https://s2.loli.net/2022/05/19/NWofAXjOs1r9x2L.png)



# 第十章：构建Web内容的技术

> 构建Web

+ HTML
+ CSS
+ JS

> Web应用

+ CGI（过时）
+ Servlet -> Spring

> 数据发布的格式及语言

+ 可拓展标记语言XML
+ RSS

+ Json

# 第十一章：Web的攻击技术

![image-20220519234358138](https://s2.loli.net/2022/05/19/JFAzISQl7jtGaDB.png)

> **简单的 HTTP 协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象。应用 HTTP 协议的服务器和客户端，以及运行在服务器上的 Web 应用等资源才是攻击目标**

:package: Q:几乎现今所有的 Web 网站都会使用会话（session）管理、加密处理等安全性方面的功能，而 HTTP 协议内并不
具备这些功能

:tea: A:因此，开发者需要自行设计并开发认证及会话管理功能来满足 Web应用的安全。而自行设计就意味着会出现各种形形色色的实现。结果，安全等级并不完备，可仍在运作的 Web 应用背后却隐藏着各种容易被攻击者滥用的安全漏洞的 Bug



## 1、因输出值转义不完全引发的安全漏洞



## 2、因设计或设计上的缺陷引发的安全漏洞



## 3、因会话管理疏忽引发的安全漏洞



## 4、其他安全漏洞

