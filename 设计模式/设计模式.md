Java设计模式



参考书籍[1]：`Java设计模式`，耿祥义、张跃平著

## 设计模式简介

### 什么是设计模式？

**一个设计模式是针对某一类问题的最佳解决方案，而且已经被成功应用于许多系统的设计中，它解决了在某种特定情景种反复发生的某个问题，因此，可以这样定义设计模式**

> **设计模式是从许多优秀的软件系统中总结出成功的可复用的设计方案**

### 23个设计模式的来源

目前,被公认在设计模式领域最具影响力的著作是 `Erich Gamma` 、`Richard Helm`、`Ralph Johnson`和`John Vlissides`在1994年合作出版的著作

> 《`Design Patterns: Elements of Reusable Object-Oriented Software`》
>
> (译本《设计模式:可复用的面向对象软件的基本原理》由机械工业出版社在2000年出版)

该书的四位作者在其著作中记录了他们在四年多的工作中所发现的23个模式。四位作者的著作成为空前的畅销书,对软件设计人员学习、掌握和使用设计模式产生了巨大的影响。《设计模式》一书被广大喜爱者呢称为GOF(Gang of Four)之书(四人帮之书),被认为是设计模式领域的奠基之作

自GOF 的《设计模式》出版后,受其影响,陆续出版了许多具有一定影响力的书籍

**书籍推荐**

+ `《Head First Design Pattern》`(中译本《Head First 设计模式》

  该书使用Java语言重点讲解GOF之书中的部分模式(13个模式),书中图文并茂,独具匠心的写作风格更是令人耳目一新,语言叙述及结构安排非常适合初学者

### 学习设计模式的必要性分析

​	**一个好的设计系统往往是易维护、易扩展、易复用的,有过一定代码编写量的程序开发人员,可能会逐渐思考程序设计问题,想知道一些优秀的设计者或团队是怎样设计出一个好的软件系统的。有经验的设计人员或团队知道如何使用面向对象语言编写出易维护、易扩展和易复用的程序代码,《设计模式》一书正是从这些优秀的设计系统中总结出的设计精髓,因此学习好设计模式对提高设计能力无疑是非常有帮助的。尽管GOF之书并没有收集全部的模式(这似乎是不可能的,也是不必要的),但所阐述的23种模式无疑是使用频率最高的模式。**
​	**设计模式的目的不是针对软件设计和开发中的每个问题都给出解决方案,而是针对某种特定环境中通常都会遇到的某种软件开发问题给出的可重用的一些解决方案,因此学习设计模式不仅可以使我们用好这些成功的模式,更重要的是可以使我们更加深刻地理解面向对象的设计思想,非常有利于我们更好地使用面向对象语言解决设计中的问题。**

​	**学习设计模式对于进一步学习、理解和掌握框架是非常有帮助的，Java EE中就大量使用了《设计模式》一书中的模式,对于熟悉设计模式的开发人员,很容易理解这些框架的结构,继而很好地使用框架来设计他们的系统。《设计模式》一书所总结的成功模式不仅适合于面向对象语言,其思想及解决问题的方式也适合于任何和设计相关的行业,因此学习掌握设计模式无疑是非常有益的**

### 该怎样去定义一个设计模式

**记录一个模式应该有以下四个要素**

> 1. **名称**
>
>    **一个模式的名称应该高度概括该模式的本质，有利于该行业统一术语**
>
> 2. **问题**
>
>    **描述应该在何时使用模式，解释设计问题和问题存在的前因后果，描述在怎样的场景下使用该模式**
>
> 3. **方案**
>
>    **描述设计的组成部分，他们之间的相互关系以及各自的职责和协作方式**
>
> 4. **效果**
>
>    **描述模式的应用效果以及使用模式应当权衡的问题，描述该模式对系统灵活性，复用性，扩充性的影响**

## 设计模式七大原则

设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即:设计模式为什么这样设计的依据)



当年 GOF 四位作者提出的设计模式主要基于以下两个原则

- 对接口编程，而不是对实现编程

- 优先使用对象组合。而不是继承

而现在我们常用的有以下七大原则

> **总原则——开闭原则 (Open Close Principle)**

**核心思想**

在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。

想要达到这样的效果，我们需要使用接口和抽象类等



**总结：**一个软件实体，如类、模块和函数应该**对扩展开放，对修改关闭**

> **单一职责原则（Single Responsibility Principle）**

**核心思想**

如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏



**总结**

一个类只负责一个功能领域中相应的职责，一个类应该只有一个发生变化的原因

> **里氏代换原则 (Liskov Substitution Principle)**：任何基类可以出现的地方，子类一定可以出现。

**核心思想**

任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。

里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，**子类对父类的方法尽量不要重写和重载**。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。



**总结**

所有引用基类的地方必须能透明地使用其子类的对象

> **依赖倒转原则 (Dependence Inversion Principle)**：针对接口编程，依赖于抽象而不依赖于具体。

**核心思想**

面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互



**总结**

1、上层模块不应该依赖底层模块，它们都应该依赖于抽象。
2、抽象不应该依赖于细节，细节应该依赖于抽象。

> **接口隔离原则 (Interface Segregation Principle)**

**核心思想**

每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好



**总结**

1、客户端不应该依赖它不需要的接口。
2、类间的依赖关系应该建立在最小的接口上

> **迪米特法则/最少知道原则 (Demeter Principle)**

**核心思想**

一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。

最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。



**总结**

一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立

> **合成复用原则 (Composite Reuse Principle)**

**核心思想**

合成或聚合可以将已有对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能



**总结**

尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的。

## 设计模式的分类

| 创建型                                  | 结构型                                | 行为型                                       |
| --------------------------------------- | ------------------------------------- | -------------------------------------------- |
| 工厂模式 (Factory Pattern)              | 适配器模式 (Adapter Pattern)          | 责任链模式 (Chain of Responsibility Pattern) |
| 工厂模式 (Factory Pattern)              | 桥接模式 (Bridge Pattern)             | 命令模式 (Command Pattern)                   |
| 抽象工厂模式 (Abstract Factory Pattern) | 过滤器模式 (Filter、Criteria Pattern) | 解释器模式 (Interpreter Pattern)             |
| 单例模式 (Singleton Pattern)            | 组合模式 (Composite Pattern)          | 迭代器模式 (Iterator Pattern)                |
| 建造者模式 (Builder Pattern)            | 装饰器模式 (Decorator Pattern)        | 中介者模式 (Mediator Pattern)                |
| 原型模式 (Prototype Pattern)            | 外观模式 (Facade Pattern)             | 备忘录模式 (Memento Pattern)                 |
|                                         | 享元模式 (Flyweight Pattern)          | 观察者模式 (Observer Pattern)                |
|                                         | 代理模式 (Proxy Pattern)              | 状态模式 (State Pattern)                     |
|                                         |                                       | 空对象模式 (Null Object Pattern)             |
|                                         |                                       | 策略模式 (Strategy Pattern)                  |
|                                         |                                       | 模板模式 (Template Pattern)                  |
|                                         |                                       | 访问者模式 (Visitor Pattern)                 |

## 学习23种设计模式

### 





